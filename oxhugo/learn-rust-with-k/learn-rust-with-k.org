#+TITLE: 陪老 K 学 Rust
#+STARTUP: inlineimages content
#+AUTHOR: Eviler
#+OPTIONS: creator:t toc:nil num:t
#+PROPERTY: header-args :eval no
#+LANGUAGE: zh-CN
#+HUGO_BASE_DIR: ../../
#+HUGO_AUTO_SET_LASTMOD: f
#+HUGO_SECTION: blog
#+HUGO_CATEGORIES: 计算机
#+HUGO_CUSTOM_FRONT_MATTTER: :authorbox true :comments true :toc false :mathjax true
#+HUGO_DRAFT: false
#+HUGO_WEIGHT: auto
#+HUGO_TAGS: Rust

* TODO 陪老 K 学 Rust (六)
:PROPERTIES:
:EXPORT_FILE_NAME: learn-rust-with-k-part6
:END:
克隆来了。
<!--more-->

** 从引用的所有权居然没有被转移开始
讲一下引用到底是什么：
** 引用和指针
讲一下胖指针：
** 实现 Clone 和 Copy trait
** 小游戏

* DONE 陪老 K 学 Rust (五)
:PROPERTIES:
:EXPORT_FILE_NAME: learn-rust-with-k-part5
:EXPORT_DATE: 2019-12-26
:END:

可变与不变
<!--more-->

** 赋值与绑定

#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn uses_foobar(foobar: &Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let mut x = Foobar(0);
    let mut z = Foobar(1);
    let mut y = &mut x;
    uses_foobar(y);
    y.0 = 1;
    uses_foobar(y);

    y = &mut z;
    uses_foobar(y);
    y.0 = 3;
    uses_foobar(y);
}
#+END_SRC

在很多语言中（其实也包括 Rust）， ~let~ 的含义并不是声明一个变量，而是进行一个值 =绑定=
操作，也就是把一个值和一个名称关联起来，从这一点上来说 =绑定= 比 =赋值= 更形象。

** 可变与不变
还记得 C 关于 ~const~ 关键字的 =常量指针= 与 =指针常量= 的问题吗？src_c[:exports
code]{const char * const p = &str;}, 我们就以分析 ~const~ 的方法
来分析 ~mut~ 关键字:

1. src_rust[:exports code]{let mut x: Foobar = Foobar(0);} 这种形式中， ~mut~ 修
   饰的是绑定关系还是值本身？ ~mut~ 只修饰变量，即修饰变量和值的绑定关系，不修
   饰值本身。
2. src_rust[:exports code]{let mut y: &mut Foobar = &mut x;} 这种引用形式中，第
   一个 ~mut~ 限定的是绑定关系，也就是 ~y~ 可以是 ~x~ 的引用绑定，也可以是其他值
   的引用绑定。 第二个 ~mut~ 限定的是被应用的值本身，即值本身的内容是否可以被此
   引用修改。第三个 ~mut~ 的作用等同于第二个 ~mut~, 在使用类型推断的情况下，这一
   点就更为明显：src_rust[:exports code]{let mut y = &mut x;}.

*** 修改值
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    println!("{:?}", x);
    x.0 = 10;
    println!("{:?}", x);
}
#+END_SRC

编译输出:
#+BEGIN_EXAMPLE
  --> l20.rs:13:5
   |
11 |     let x = Foobar(0);
   |         - help: consider changing this to be mutable: `mut x`
12 |     println!("{:?}", x);
13 |     x.0 = 10;
   |     ^^^^^^^^ cannot assign

error: aborting due to previous error
#+END_EXAMPLE

结论：非 ~mut~ 绑定不能修改值的内容。

#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let mut x = Foobar(0);
    println!("{:?}", x);
    x.0 = 10;
    println!("{:?}", x);
}
#+END_SRC

编译运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(10)
Dropping a Foobar: Foobar(10
#+END_EXAMPLE
结论： ~mut~ 绑定可以修改值的内容。

*** 修改绑定关系
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    let y = Foobar(1);
    println!("{:?}", x);
    x = y;
    println!("{:?}", x);
}
#+END_SRC

编译输出：
#+BEGIN_EXAMPLE
error[E0384]: cannot assign twice to immutable variable `x`
  --> l20.rs:14:5
   |
11 |     let x = Foobar(0);
   |         -
   |         |
   |         first assignment to `x`
   |         help: make this binding mutable: `mut x`
...
14 |     x = y;
   |     ^ cannot assign twice to immutable variable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0384`
#+END_EXAMPLE

结论：非 ~mut~ 绑定不能修改绑定关系。

#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let mut x = Foobar(0);
    println!("{:?}", x);
    let y = Foobar(1);
    println!("{:?}", y);
    x = y;
    println!("{:?}", x);
    x.0 = 10;
    println!("{:?}", x);
}
#+END_SRC

编译运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(1)
Dropping a Foobar: Foobar(0)
Foobar(1)
Foobar(10)
Dropping a Foobar: Foobar(10)
#+END_EXAMPLE

结论： ~mut~ 绑定可以修改绑定关系，并且可以修改值的内容。这个修改与 ~y~ 原来是否
是 ~mut~ 无关。

*** 重置绑定
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    println!("{:?}", x);
    let x = Foobar(1);
    println!("{:?}", x);
}
#+END_SRC

编译运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(1)
Dropping a Foobar: Foobar(1)
Dropping a Foobar: Foobar(0
#+END_EXAMPLE

结论： 无论是否是 ~mut~ 绑定，都可以重新绑定。

*** 可变性修改
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    println!("{:?}", x);
    let mut y = x;
    println!("{:?}", y);
    y.0 = 1;
    println!("{:?}", y);
}
#+END_SRC

运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(0)
Foobar(1)
Dropping a Foobar: Foobar(1)
#+END_EXAMPLE

根据以上代码，下面的 mutable move 也就很好理解了。
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

fn main() {
    let x = Foobar(1);
    foo(x);
}

fn foo(mut x: Foobar) {

    x.0 = 2; // changes the 0th value inside the product

    println!("{:?}", x);
}
#+END_SRC

运行输出：
#+BEGIN_EXAMPLE
Foobar(2)
#+END_EXAMPLE

*** 不变引用不变值绑定
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    let y = &x; // let y: &Foobar = &x;
    println!("{:?}", x);
    println!("{:?}", y);
}
#+END_SRC

编译运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(0)
Dropping a Foobar: Foobar(0)
#+END_EXAMPLE

#+BEGIN_QUOTE
src_rust[:exports code]{println!("{:?}", x)} 难道不会接管 ~x~ 的所有权吗？注意：
println! 是宏而不是函数，你焉不知这个宏看上去是用的 ~x~, 在背后用的是 ~&x~ 呢？
#+END_QUOTE

*** 不变引用可变值绑定

#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let mut x = Foobar(0);
    println!("{:?}", x);
    let y = &mut x; // let y: &mut Foobar = &mut x;
    println!("{:?}", y);
    y.0 = 10;
    println!("{:?}", y);
}
#+END_SRC

编译运行输出:
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(0)
Foobar(10)
Dropping a Foobar: Foobar(10)
#+END_EXAMPLE

#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let mut x = Foobar(0);
    println!("{:?}", x);
    let y = &mut x; // let y: &mut Foobar = &mut x;
    println!("{:?}", y);
    let mut z = Foobar(1);
    y = &mut z;
    println!("{:?}", y);
}
#+END_SRC

编译报错：
#+BEGIN_EXAMPLE
error[E0384]: cannot assign twice to immutable variable `y`
  --> l20.rs:16:5
   |
13 |     let y = &mut x; // let y: &mut Foobar = &mut x;
   |         -
   |         |
   |         first assignment to `y`
   |         help: make this binding mutable: `mut y`
...
16 |     y = &mut z;
   |     ^^^^^^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0384`.
#+END_EXAMPLE

结论： ~y~ 是不变引用，其引用的值被 ~mut~ 修饰为可变。即： ~y~ 的绑定关系不能修
改，但是 ~y~ 指向的值可以被修改。

*** 可变引用不变值绑定
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    println!("{:?}", x);
    let mut y = &x; // let mut y: &Foobar = &mut x;
    println!("{:?}", y);
    let z = Foobar(1);
    y = &z;
    println!("{:?}", y);
}
#+END_SRC

运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(0)
Foobar(1)
Dropping a Foobar: Foobar(1)
Dropping a Foobar: Foobar(0)
#+END_EXAMPLE

结论：可变引用可以改变绑定关系， ~y~ 并不特殊，也遵循可变绑定和不变绑定。

*** 可变引用可变值绑定
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let mut x = Foobar(0);
    println!("{:?}", x);
    let mut y = &mut x; // let mut y: &Foobar = &mut x;
    println!("{:?}", y);
    let mut z = Foobar(1);
    y = &mut z;
    println!("{:?}", y);
}
#+END_SRC

运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(0)
Foobar(1)
Dropping a Foobar: Foobar(1)
Dropping a Foobar: Foobar(0)
#+END_EXAMPLE

结论：可变引用可以改变绑定关系， ~y~ 并不特殊，也遵循可变绑定和不变绑定。

*** 不变引用的共享性
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    let y = &x; // let y: &Foobar = &x;
    let z = &x; // let z: &Foobar = &x;
    println!("{:?}", x);
    println!("{:?}", y);
    println!("{:?}", z);
}
#+END_SRC
运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(0)
Foobar(0)
Dropping a Foobar: Foobar(0)
#+END_EXAMPLE

结论： ~x~, ~y~, ~z~ 随便用。

*** 可变引用的排他性
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let mut x = Foobar(0);
    let y = &mut x; // let y: &mut Foobar = &mut x;
    let z = &x; // let z: &Foobar = &x;
    println!("{:?}", x);
    println!("{:?}", y);
    println!("{:?}", z);
}
#+END_SRC

编译报错：
#+BEGIN_EXAMPLE
error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --> l20.rs:13:13
   |
12 |     let y = &mut x; // let y: &Foobar = &x;
   |             ------ mutable borrow occurs here
13 |     let z = &x; // let z: &Foobar = &x;
   |             ^^ immutable borrow occurs here
14 |     println!("{:?}", x);
15 |     println!("{:?}", y);
   |                      - mutable borrow later used here

error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --> l20.rs:14:22
   |
12 |     let y = &mut x; // let y: &Foobar = &x;
   |             ------ mutable borrow occurs here
13 |     let z = &x; // let z: &Foobar = &x;
14 |     println!("{:?}", x);
   |                      ^ immutable borrow occurs here
15 |     println!("{:?}", y);
   |                      - mutable borrow later used here

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0502`.
#+END_EXAMPLE

结论：
1. ~println!~ 宏的确是转换成了引用。
2. 在 ~y~ 可变借用了 ~x~, 以后， ~println!~ 的不变引用被拒绝。

*** 强制不变引用和强制可变引用
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let mut x = Foobar(0);
    let y = &x; // let y: &Foobar = &x;
    let z = &x; // let z: &Foobar = &x;
    println!("{:?}", x);
    println!("{:?}", y);
    println!("{:?}", z);
}
#+END_SRC

编译运行输出:
#+BEGIN_EXAMPLE
warning: variable does not need to be mutable
  --> l20.rs:11:9
   |
11 |     let mut x = Foobar(0);
   |         ----^
   |         |
   |         help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` on by default

Foobar(0)
Foobar(0)
Foobar(0)
Dropping a Foobar: Foobar(0)
#+END_EXAMPLE

除了一个 ~x~ 的未使用的 ~mut~ 限定意外，运行没毛病，也就是： *可以以不变的方式引
用可变绑定*. 那我们反过来，以可变的方式应用不变绑定呢？
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    let y = &mut x; // let y: &mut Foobar = &mut x;
    println!("{:?}", y);
}
#+END_SRC

编译报错：
#+BEGIN_EXAMPLE
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
  --> l20.rs:12:13
   |
11 |     let x = Foobar(0);
   |         - help: consider changing this to be mutable: `mut x`
12 |     let y = &mut x; // let y: &mut Foobar = &mut x;
   |             ^^^^^^ cannot borrow as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
#+END_EXAMPLE

结论： *不能* 把不变绑定强制转换成可变引用。

#+BEGIN_QUOTE
扩展一下思路，在函数参数传递的场景下， ~mut~ 的原则又是什么呢？
1. src_rust[:exports code]{fn uses_foobar(foobar: &Foobar)}
2. src_rust[:exports code]{fn uses_foobar(mut foobar: &Foobar)}
2. src_rust[:exports code]{fn uses_foobar(foobar: &mut Foobar)}
3. src_rust[:exports code]{fn uses_foobar(mut foobar: &mut Foobar)}
#+END_QUOTE

** 再论可变与不变

由以上的栗子可知： ~Foobar~ 自身完全没有权利决定自己的内容是可变的还是不变的，其内
容能否可变，取决于在其被绑定时的绑定方式。象 ~Foopbar~ 这种元组还不是特别明显，
以 ~struct~ 作为参考：

#+caption: Hello
#+BEGIN_SRC rust
struct Greet {
    age: i32,
    score: i32
}

fn main() {
    let f1 = Greet{age: 18, score: 60};
    let mut f2 = Greeg{age: 20, score: 80};
}
#+END_SRC

在以上代码中，实际上 ~Greet~ 的字段都是默认可变的。:( 这听上去怎么和 Rust 的值默
认不变相矛盾？

在其他一些语言中， ~let~ 和 ~var~ 来分别代表不变绑定和可变绑定（如：swift），并
且可变和不可变的作用是单一的，只用来限定绑定关系是否可变。值本身的内容由值的类型
来决定，这么说有些抽象，还是拿 ~Greet~ 的栗子来说：

#+BEGIN_SRC swift
struct Greet {
    let age: Int32,
    var score: Int32,
}

func main() {
    let f1 = Greet(age: 10, score: 60)
    f1.score = 80 // Ok, 因为 score 是 var, 可变的.
    f1 = Greet(age: 20, score: 80) // Nope, 因为 f1 是 let, 不变的，不能改变绑定关系。

    var f2 = Greet(age: 10, score: 60)
    f2.age = 10 // Nope: 虽然 f2 是可变的，但是 age 在 struct 内部是不变的。
    f2 = Greet(age: 20, score: 80) // Ok, f2 可以重复绑定。
}
#+END_SRC

相对比来说， swift 的模型貌似更符合一个正常的心智模型，而 Rust 确是怪怪的，私自
以为 rust 对于 ~mut~ 的处理非常不合理，一个数据类型是否可变居然不取决于其自身的设计。
在设计之初，没有不可变的选择。:(, 相反在这一点上 ~swift~ 更加合理。

** 胡乱说的模型
如果 Rust 代码的语法是这样的，可能一致性更好一些：
#+BEGIN_SRC rust
fn main() {
    let x: mut Foobar = mut Foobar(0);
    let mut y: mut Foobar = mut Foobar(1);
    let mut z = mut Foobar(3);
    let o: Foobar = Foobar(4);
}
#+END_SRC
这样，第一个 ~mut~ 修饰绑定关系，第二个 ~mut~ 修饰内容就和 =借用/引用= 保持一致
了。：） 可惜现实不是这样的，我们姑且把 src_rust[:exports code]{let x: mut
Foobar = mut Foobar(0);} 这种看成是默认的语法糖吧。

* DONE 陪老 K 学 Rust (四)
:PROPERTIES:
:EXPORT_FILE_NAME: learn-rust-with-k-part4
:EXPORT_DATE: 2019-12-25
:END:

借用和引用
<!--more-->

** 词法空间
不久以前，Rust 的变量作用域是基于词法的，最近一年（可能）Rust 合并了 =非词法作用
域= 生命周期的特性 (NLL, No Lexical Liftime)，使得变量的生命周期不再严格遵循词法
域了，关于 NLL 的详细情况可以参考这篇文章：[[https://zhuanlan.zhihu.com/p/32884290]] .
下面的代码演示了基于词法域的变量生命周期：
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

Fn main() {
    println!("Before x");
    let _x = Foobar(1);
    println!("After x");
    {
        println!("Before y");
        let _y = Foobar(2);
        println!("After y");
    }
    println!("End of main");
}
#+END_SRC

#+BEGIN_QUOTE
在 ~x~ 和 ~y~ 变量之前加下划线是为了抑制 Rust 编译器的报错，对于不使用的变量，
Rust 会发出编译警告。
#+END_QUOTE

运行代码可以看出变量 ~_x~, ~_y~ 的生命周期是严格遵循作用域的。
#+BEGIN_EXAMPLE
Before x
After x
Before y
After y
Dropping a Foobar: Foobar(2)
End of main
Dropping a Foobar: Foobar(1)
#+END_EXAMPLE

如果去掉多余的 ~{}~, 猜测一下变量 ~_x~ 和 ~_y~ 的生命周期？它们会不是以创建的逆
序释放呢？验证一下：
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    println!("Before x");
    let _x = Foobar(1);
    println!("After x");
        println!("Before y");
        let _y = Foobar(2);
        println!("After y");
    println!("End of main");
}
#+END_SRC

#+BEGIN_EXAMPLE
Before x
After x
Before y
After y
End of main
Dropping a Foobar: Foobar(2)
Dropping a Foobar: Foobar(1)
#+END_EXAMPLE

可以看出，释放是按照创建的 *逆序* 进行的，值得信赖！

** 借用和引用
很多情况下，我们希望在不转移值的所有权(不改变变量的属主）的情况下使用变量。很简
单，Rust 提供了一种叫做 =引用= 的机制来满足我们的需求。 =借用= 和 =引用= 是一回
事，只是概念的侧重点不一致。 =借用= 是针对 =所有权机制= 而言的。 =引用= 是形式，
是针对变量使用的方式而言的。
#+BEGIN_QUOTE
通常变量变量的使用方式遵循两种形式： =值拷贝= 和 =引用=. =值拷贝= 是通过复制一个
新的值进行使用，在参数传递（通常的 =值传参=)，赋值等操作中使用. =引用= 是通过值复制值所
在的地址进行使用的，典型的应用就是在 =引用传参=, 值共享等场景。
#+END_QUOTE

编译下面的代码:
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn uses_foobar(foobar: Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x = Foobar(1);

    uses_foobar(x);
    uses_foobar(x);
}
#+END_SRC

编译器会输出如下的错误：

#+BEGIN_EXAMPLE
error[E0382]: use of moved value: `x`
  --> l15.rs:19:17
   |
16 |     let x = Foobar(1);
   |         - move occurs because `x` has type `Foobar`, which does not implement the `Copy` trait
17 |
18 |     uses_foobar(x);
   |                 - value moved here
19 |     uses_foobar(x);
   |                 ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
#+END_EXAMPLE

第二个src_rust[:exports code]{uses_foobar(x);} 使用了所有权已经转移的值。
根据编译器的建议，我们可以使用几种方法来修复：
1. 对于 ~Foobar~ 类型，我们实现 ~Copy~ trait.
2. 对于 ~uses_foobar~ 函数，我们使用 =引用传参= 的方式 =借用= ~Foobar(1)~ 的所有
   权，如同在 ~Drop~ trait 里面的 ~drop~ 函数的第一个参数 ~self~ 那样。

** 同时引用
不象所有权属主，一个值可以同时被多次以 =引用= 的方式使用。如下代码段:
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn uses_foobar(foobar: &Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x: Foobar = Foobar(1);
    let y: &Foobar = &x;
    println!("Before uses_foobar");
    uses_foobar(&x);
    uses_foobar(y);
    println!("After uses_foobar");
}
#+END_SRC
在这里， ~Foobar(1)~ 两次被以引用的方式使用，一次是作为 =引用参数= 直接传递给
~uses_foobar~, 另外一次是被变量 ~y~ 以应用的方式使用，并以参数的方式传递给
~uses_foobar~. 在这段代码中，局部变量 ~y~ 的类型是显示声明的，而不是使用的 =类型
= 推断的方式。代码输出如下：
#+BEGIN_EXAMPLE
Before uses_foobar
I consumed a Foobar: Foobar(1)
I consumed a Foobar: Foobar(1)
After uses_foobar
Dropping a Foobar: Foobar(1)
#+END_EXAMPLE

代码可以正常运行的原因在于。
1. 多次的 *只读* 引用不会引发数据竟态。
2. 值本身的生命周期要比引用的生命周期长，也就是说，变量 ~x~ 要比变量 ~y~ 的生命
   周期长。

src_rust[:exports code]{std::mem::drop} 函数可以主动触发值的失效操作。使用此函数
来结束变量 ~x~ 的值的生命周期。

#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn uses_foobar(foobar: &Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x: Foobar = Foobar(1);
    let y: &Foobar = &x;
    println!("Before uses_foobar");
    uses_foobar(&x);
    std::mem::drop(x);
    uses_foobar(y);
    println!("After uses_foobar");
}
#+END_SRC

编译器检查出借用的生命周期超出了其所有权属主的生命周期。
#+BEGIN_EXAMPLE
error[E0505]: cannot move out of `x` because it is borrowed
  --> l17.rs:19:20
   |
16 |     let y: &Foobar = &x;
   |                      -- borrow of `x` occurs here
...
19 |     std::mem::drop(x);
   |                    ^ move out of `x` occurs here
20 |     uses_foobar(y);
   |                 - borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0505`
#+END_EXAMPLE

** 可变引用
当然，我们也可以以 =可变引用= 的方式来使用某个值，为了避免数据出现竟态，Rust 不
允许同时出现多个 =可变引用= 或者在被可变引用的情况下以其他方式（包括 =只读引用=
）访问。
#+BEGIN_SRC rust
fn main() {
    let x: Foobar = Foobar(1);
    let y: &mut Foobar = &mut x;
    println!("Before uses_foobar");
    uses_foobar(&x); // 编译报错
    std::mem::drop(x);
    uses_foobar(y);
    println!("After uses_foobar");
}
#+END_SRC

#+BEGIN_EXAMPLE
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
  --> l17.rs:16:26
   |
15 |     let x: Foobar = Foobar(1);
   |         - help: consider changing this to be mutable: `mut x`
16 |     let y: &mut Foobar = &mut x;
   |                          ^^^^^^ cannot borrow as mutable

error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --> l17.rs:18:17
   |
16 |     let y: &mut Foobar = &mut x;
   |                          ------ mutable borrow occurs here
17 |     println!("Before uses_foobar");
18 |     uses_foobar(&x); // 编译报错
   |                 ^^ immutable borrow occurs here
19 |     std::mem::drop(x);
20 |     uses_foobar(y);
   |                 - mutable borrow later used here

error[E0505]: cannot move out of `x` because it is borrowed
  --> l17.rs:19:20
   |
16 |     let y: &mut Foobar = &mut x;
   |                          ------ borrow of `x` occurs here
...
19 |     std::mem::drop(x);
   |                    ^ move out of `x` occurs here
20 |     uses_foobar(y);
   |                 - borrow later used here

error: aborting due to 3 previous errors

Some errors have detailed explanations: E0502, E0505, E0596.
For more information about an error, try `rustc --explain E0502`
#+END_EXAMPLE

* DONE 陪老 K 学 Rust (三)
:PROPERTIES:
:EXPORT_FILE_NAME: learn-rust-with-k-part3
:EXPORT_DATE: 2019-12-24
:END:

从简单的栗子开始。

<!--more-->

** 从简单的栗子开始
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

fn uses_foobar(foobar: Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x = Foobar(1);
    uses_foobar(x);
}
#+END_SRC

src_rust[:exports code]{#[derive(Debug)]} 是一个编译器程序，这里让 ~Foobar~ 继承
~Debug~ trait, 以便于后面的 ~uses_foobar~ 函数中调用 ~println!~ 使用 ~{:?}~ 占位符进行插值打印。

src_rust[:exports code]{struct Foobar(i32);} 将一个 =元组= 封装成新的数据类型 =Foobar=.

运行程序可以看到打印输出。
#+BEGIN_EXAMPLE
I consumed a Foobar: Foobar(1)
#+END_EXAMPLE


现在修改一下 ~main~ 函数，我们仅仅是希望打印两次 ~x~ 的值，所以调用了两次
~uses_foobar~ 。
#+BEGIN_SRC rust
fn main() {
    let x = Foobar(1);

    uses_foobar(x);
    uses_foobar(x);
}
#+END_SRC

编译代码，可以看到编译器报错了：

#+BEGIN_EXAMPLE
error[E0382]: use of moved value: `x`
  --> l11.rs:11:16
   |
9  |     let x = Foobar(1);
   |         - move occurs because `x` has type `Foobar`, which does not implement the `Copy` trait
10 |     use_foobar(x);
   |                - value moved here
11 |     use_foobar(x);
   |                ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`
#+END_EXAMPLE

** ~Drop~ trait
Rust 的值在超出其作用域以后会被释放，内存也会被回收，这没什么槽点，因为在 C 语言
中，所有的栈上的 =局部变量= 也是这样的。 我们按照自己的思维定势来分析下发生了什
么。

#+BEGIN_SRC rust
fn main() {
    let x = Foobar(1); // 局部变量 x, 没问题。

    uses_foobar(x); // 传入 x 使用。
    uses_foobar(x); // 传入 x 使用。
}
// main 函数退出， x 被释放回收。
#+END_SRC

~Drop~ trait 是 Rust 中变量释放时运行的清理代码。其实现如下:
#+BEGIN_SRC rust
impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}
#+END_SRC

这里提前引入了 src_rust[:exports code]{&mut self} 这种参数传递方式，后面很快就解
释它。为了更清楚得分析，故意创造几个作用域并在关键点进行打印。
#+BEGIN_SRC rust
fn main() {
    println!("before enter scope");
    {
        println!("enter scope");
        let x = Foobar(1);
        println!("before uses_foobar");
        //uses_foobar(x);
        println!("after uses_foobar");
        println!("will leave scope");
    }
    println!("leave scope");
}
#+END_SRC

以上代码输出:
#+BEGIN_EXAMPLE
before enter scope
enter scope
before uses_foobar
after uses_foobar
will leave scope
Dropping a Foobar: Foobar(1)
leave scope
#+END_EXAMPLE

符合我们的预期，现在加入 ~uses_foobar~ 调用：
#+BEGIN_SRC rust
fn main() {
    println!("before enter scope");
    {
        println!("enter scope");
        let x = Foobar(1);
        println!("before uses_foobar");
        uses_foobar(x);
        println!("after uses_foobar");
        println!("will leave scope");
    }
    println!("leave scope");
}
#+END_SRC

输出：
#+BEGIN_EXAMPLE
before enter scope
enter scope
before uses_foobar
I consumed a Foobar: Foobar(1)
Dropping a Foobar: Foobar(1)
after uses_foobar
will leave scope
leave scop
#+END_EXAMPLE

看 =Dropping= 的时机，两个代码段明显不一样，而且第二个代码段的输出明显和我们预想的
不一样，发生了什么？

从感觉上来说，两段代码中 =x= 的释放时机应该没有区别. 但实际上，在第二段代码中，
x 在 ~uses_foobar(x);~ 之后就被释放了。这就是 Rust 所特有的所有权系统所起的作用。

众所周知，语言中的变量的生命周期都是基于词法域的。在 Rust 中，除了变量具有生命周
期， =值= 也有生命周期，每个 =值= 都 *有且只有* 一个其属主变量。 一旦 =值= 的属
主变量的生命周期结束，则值的生命周期也结束。当然，如果任何情况下， =值= 的生命周
期和 =变量= 的生命周期一致的话，所有权系统也就没有存在的必要了。既然其存在，就必
然有一些情况下， =值= 的生命周期和其属主变量的生命周期不一致。其中很常见的一种情
况就是：把 =值= 从其属主变量赋值给了另外一个变量，则新的变量就变成了 =值= 的属主
变量， =值= 的生命周期就保持和新的属主变量的生命周期保持一致。从这个角度来解释上
面的代码段二就是:

把 ~x~ 传递给 ~uses_foobar~ 函数时， ~Foobar(1)~ 的属主从变量 ~x~ 变成了函数
src_rust[:exports code]{fn uses_foobar(foobar: Foobar)} 的形参 ~foobar~,
在 ~uses_foobar~ 函数体结束后，形参 ~foobar~ 的生命结束， ~Foobar(1)~ 的生命周期
也随着 ~foobar~ 的生命周期结束而结束，故而调用了 ~Drop~ trait. 而代码一中，
~Foobar(1)~ 的属主变量从未改变过，一直是 ~x~, 所以在 x 退出其词法域而结束其生命
周期时， ~Foobar(1)~ 的生命周期才结束。

那搞得如此复杂的目的在于什么呢？或者说 Rust 搞这一套复杂的机制是为了解决什么问题
呢？主要为了两个目的：
1. 对于值，可以严格判定其生命周期，一旦其属主根据词法域结束生命周期后，就可以调
   用 ~drop~ 自动释放，从而做到了对于内存管理的 =零抽象=. 想想在 C/C++ 语言中的
   ~malloc~ 和 ~free~, 一方面，我们不得不时刻紧记要 ~free~ 内存，以避免内存泄漏。
   另一方面，我们还要时刻注意不要过度 ~free~, 从而造成野指针（好吧，其实现在 C++
   有智能指针了）。另外这种自动内存的管理不是通过 =引用计数= 或者 =GC= 来进行
   的，而是在编译期就可以确定的，避免使用一个保持 =引用计数= 或者 =GC= 能正常运
   行的运行时。
2. 对于多线程情况下，可以严格控制值的访问，避免出现多个线程代码同时访问同一个变
   量而引发的 BUG. 这种竟态往往是 BUG 出现的主要因素并且难以避免，难以复现，难以
   调试。往往我们需要借助静态代码分析工具来仔细分析，还不一定能够全部避免。按照这种所
   有权机制所提供的策略编写代码确可以 100% 避免这种情况，虽然这种策略看上去非常死
   板，不够灵活。但是作为一个码农来说，写正确的代码才是第一位的。当然不遵循这种
   策略可能也能写出安全的代码，但是遵循这种策略确一定能写出安全的代码，并且还自
   带静态分析工具，我们何乐而不为呢？

* DONE 陪老 K 学 Rust (二)
:PROPERTIES:
:EXPORT_FILE_NAME: learn-rust-with-k-part2
:EXPORT_DATE: 2019-12-20
:END:

万年的 ~Hello World!~.
<!--more-->

** 宏
#+BEGIN_SRC rust
fn main() {
    println!("Hello, world!");
}
#+END_SRC

很简单的 ~main~ 函数，跟 C 语言的 =hello world= 程序差不多。 =fn= 表示 ~main~ 是
一个函数，它没有参数，也没有返回值（严格来讲，其返回值是 ~()~ ）。 ~println!~ 看
上去是一个函数，实际上是一个宏，宏是一段运行在编译器上的代码。对，跟 C/C++ 的宏
类似，但是从功能上来说，Rust 的宏比 C/C++ 的宏更加强大。 宏和函数的区别可以通过
如下的例子来理解。

假如我们有一个 ~println~ 函数，它类似于 C 语言的 ~printf~ 函数，接受可以格式化的
字符串参数，可能会这样调用：
#+BEGIN_SRC rust
println("This is a string format print: name: {}, value: {}", name, value);
#+END_SRC
从编译器的角度来看， ~println~ 函数的第一个参数是一个字符串，其内部的插值占位符
~{}~, 编译器是无法理解的，这样的后果就是我们即使向 ~println~ 函数中传入 3 或者 4
个参数，编译器在编译阶段也不会报错。但是宏不一样，我们可以编写一段代码来操纵编译
器，使之能理解 ~println~ 函数的第一个字符串参数内部的占位符，从而对后面的参数个
数以及类型进行检查，一旦码农传入了非法的参数，在编译阶段就可以检查出错误来。那这
段代码就是 ~println!~ 宏，而且比 C 语言中的 ~printf~ 更强大，因为 ~printf~ 函数
是无法对参数进行合法性检查的。

#+BEGIN_QUOTE
思考：

是不是可以编写一个执行数据库检查的宏： src_rust[:exports code]{execute_sql!("select name, age from
user_table where age < {}", min_age);} 不仅能对格式化的参数合法性进行检查，甚至
能对其内部的 SQL 语句的合法性进行检查？
#+END_QUOTE

** =Trait= 和 =Display=

#+NAME: 程序一
#+BEGIN_SRC rust
struct Person {
    name: String,
    age: u32,
}

fn main() {
    let alice = Person {
        name: String::from("Alice"),
        age: 30,
    };
    println!("Person: {}", alice);
}
#+END_SRC

编译报错：

#+BEGIN_EXAMPLE
error[E0277]: `Person` doesn't implement `std::fmt::Display`
  --> t001.rs:11:28
   |
11 |     println!("Person: {}", alice);
   |                            ^^^^^ `Person` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Person`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
   = note: required by `std::fmt::Display::fmt`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`
#+END_EXAMPLE

错误的原因是 Person 没有实现 =std::fmt::Display= Trait. 实现这个 Trait 就能够修
复这个错误。

#+BEGIN_SRC rust
impl std::fmt::Display for Person {
    fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::result::Result<(), std::fmt::Error> {
        write!(fmt, "{} ({} yeas old)", self.name, self.age)
    }
}
#+END_SRC

结论：
1. Rust 中没有面向对象的概念， ~trait~ 也不是 ~class~, *没有继承*!
2. Rust 使用 ={}= 进行字符串插值时，被插值参数必须要实现 =std::fmt::Display= Trait.
3. =&self= 是 =self: &Self= 的语法糖。
4. =()= 类似 C 语言中的 =void=, 不同的是 =()= 既是类型，也是值。
5. 命名约定： 宏都以 =!= 结尾。
6. 与 C++ 不同，Rust 用 =::= 来表示域，C++ 用 ~:~ 。
7. ~&~ 表示使用 =引用= 的方式传参，这一点和 C++ 类似。

#+BEGIN_QUOTE
作为一个老鸟，肯定会思考：既然字符串插值的占位符是 ~{}~, 那如果要打印原始的 ~{}~ 该如何转义呢？

猜一下， 是 ~{{{}~ ? 不美观，而且看样占位符实际上是两个字符: ={= 和 =}=, 美观点
也应该是： ~{{}}~.

Right!
#+END_QUOTE

** 分号

#+BEGIN_SRC rust
impl std::fmt::Display for Person {
    fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::result::Result<(), std::fmt::Error> {
        write!(fmt, "{} ({} yeas old)", self.name, self.age)
    }
}
#+END_SRC

这段代码中的函数 ~fmt~ 函数体中只有一个语句： ~write!~, 而且这一个语句的后面 *没有*
分号！并且此函数明确标明了返回一个 ~Result~ 类型的值，但是函数体内部并没有
~return~. 这不是错误。Rust 是一门基于表达式的语言，也就是说，任何 Rust 语句都是一个表
达式，表达式的特点就是可以对其进行求值。语句分为两种：
1. 声明语句: 是一种特殊的表达式， ~let~, ~use~, ~crate~, ~fn~, ~struct~, ~trait~, ~impl~ 等等。这些使用其副作用的语句，其值为 ~()~.
2. 表达式语句: 由一个表达式和分号共同组成的语句。在一个表达式后面添加 ~;~ 就构成了表
   达式语句。当使用 ~;~ 把表达式强制变成语句之后，则此表达式语句的值被抑制，强制变为 ~()~.
  
#+BEGIN_QUOTE
思考

既然 Rust 中一切都是表达式，为什么还要在表达式的后面添加一个 ~;~ 使之变成表达式
语句？
#+END_QUOTE

既然在 Rust 中一切皆表达式，则 ~{}~ 组成的代码块也是表达式。由 ~{}~ 组成的代码块
的表达式的值就是 ~{}~ 最后一个表达式的值。
#+BEGIN_SRC rust
let a = {
    let inner = 2;
    inner * inner
}
#+END_SRC

上面代码中 ~a~ 的值是 4. 但是如果 src_rust[:exports code]{ inner * inner } 用
~;~ 强制转换成语句后， ~a~ 的值和类型都变成了 ~()~.

函数的返回值也一样，在 Rust 的函数体中，最后一个表达式的值作为函数的返回
值。 ~return~ 语句通常用在提前返回的情况下。

** 数字类型

Rust 中的数字类型都是明确的，并且类型之间只能使用 ~as~ 进行显示转换，不允许类似
C 语言那样的隐式转换。Rust 的类型名称也比较有规律：

#+ATTR_HTML: :border 2 :rules all :frame border :class striped table-striped noboldheader
|--------+--------+--------+--------+----------+-----------|
| 单字节 | 双字节 | 四字节 | 八字节 | 十六字节 | 四/八字节 |
|--------+--------+--------+--------+----------+-----------|
| i8     | i16    | i32    | i64    | i128     | isize     |
| u8     | u16    | u32    | u64    | u128     | usize     |
|--------+--------+--------+--------+----------+-----------|

再也不用费劲记忆 ~short~, ~int~, ~long~, ~longlong~ 是多少字节了。:)
~iszie~ 和 ~usize~ 比较特殊一点，想来是为了方便和 C 进行混合编程。

** 循环打印数字
#+BEGIN_SRC rust
fn main() {
    let i = 1;

    loop {
        println!("i == {}", i);
        if i >= 10 {
            break;
        } else {
            i += 1;
        }
    }
}
#+END_SRC

#+BEGIN_SRC rust
fn main() {
    let i = 1;

    while i <= 10 {
        println!("i == {}", i);
        i += 1;
    }
}
#+END_SRC

以上代码都有编译错误，主要就是需要注意可变变量和不变变量。 比较奇怪的一点是既然
有 ~while~ 了，为什么还增加一个 ~loop~? 一种说法是对于循环来说， ~loop~ 更方便编
译器检查错误，因为只要其中不包含 ~break~ 语句，就会被编译器检查出来，但是 ~while~ 语
句的条件检查只有在运行期才能知道，编译期是无法知道的，也就无法在编译期进行检查。

#+BEGIN_SRC rust
fn main() {
    for i in 1..11 {
        println!("i == {}", i);
    }
}
#+END_SRC

~for~ 语句和 C 长得不一样了， Rust 的 ~for~ 变成了 =迭代= 的形式。

* DONE 陪老 K 学 Rust (一)
:PROPERTIES:
:EXPORT_FILE_NAME: learn-rust-with-k-part1
:EXPORT_DATE: 2019-12-18
:END:

开始之前的环境配置， 本节是繁琐的准备工作，已经完成的同学可以跳过。
<!--more-->

** 安装工具链
我的环境是 MacOS, 并且使用 HomeBrew 来管理软件的安装。

修改环境变量，在 =~/.zshrc= 文件中添加如下配置：

#+BEGIN_EXAMPLE
export CARGO_HOME=/usr/local/var/cargo
export RUSTUP_HOME=/usr/local/var/rustup
export RUSTUP_DIST_SERVER="https://mirrors.ustc.edu.cn/rust-static"
export RUSTUP_UPDATE_ROOT="https://mirrors.ustc.edu.cn/rust-static/rustup"
export PATH="${PATH}:${CARGO_HOME}/bin"
if (command -v rustc > /dev/null 2>&1); then
    export RUST_SRC_PATH="$(rustc --print sysroot)/lib/rustlib/src/rust/src"
fi
#+END_EXAMPLE

以上的配置解释：
- =cargo= 是 Rust 的包管理软件， =CARGO_HOME= 用来配置 cago 包的安装目录，我更喜欢安装在 =/usr/local/var/cargo= 目录下。
- =rustup= 是 Rust 工具链管理命令行工具。
- =RUST_DIST_SERVER= 和 =RUST_UPDATE_ROOT=: 避免 GFW 的干扰，使用中科大的镜像。
- =RUST_SRC_PATH= Rust 源代码路径，对标准库的功能进行文档提示或者补全之用。

使配置生效：
#+BEGIN_EXAMPLE
source ~/.zshrc
#+END_EXAMPLE

安装 =rust-init=

#+BEGIN_EXAMPLE
brew install rustup-init
rustup-init
#+END_EXAMPLE

安装 Rust 稳定版本的编译器等工具链并设置为默认工具链。
#+BEGIN_EXAMPLE
rustup default stable
#+END_EXAMPLE

Rust 的编译工具链命名遵循规范： =<channel>[-<date>][-<host>]=. 各个部分说明如下：

#+BEGIN_EXAMPLE
<channel>       = stable|beta|nightly|<version>
<date>          = YYYY-MM-DD
<host>          = <target-triple>
#+END_EXAMPLE

如： =stable=, =stable-x86_64-pc-windows-msvc=, =nightly-2019-11-04= 等都是合法
的工具链名称。特别注意的是 =channel=, =stable= 表示是稳定版本， =nightly= 表示为
每日构建版本。部分实验性的功能或者特性只有在 =nightly= 版本中支持。有些第三方库
在构建的时候可能要求你的工具链是 =nightly= 版本。但是截至到现在（2019-12-18)
=stable= 版本的特性已经足够我们学习的了。：）

#+BEGIN_EXAMPLE
rustup component add rls clippy rust-analysis rust-src rustfmt
#+END_EXAMPLE

安装一些辅助用的工具：
- =rls= 全称是 Rust Language Server, 就是支持微软的 =lsp= 的语言服务器，对编辑器进行语法提示，语义级别的检索以及智能提示等功能。
- =clippy= Rust 语法检查工具。
- =rust-analysis= Rust 分析器。
- =rust-src= Rust 源码。
- =rustfmt= Rust 源代码格式化工具。

安装完成以后不要忘了检查一下是否安装成功：

#+BEGIN_EXAMPLE
╭ kerberos@kmacbookh   ~ 
╰ cargo version
cargo 1.38.0 (23ef9a4ef 2019-08-20)
╭ kerberos@kmacbookh   ~ 
╰ rustc --version
rustc 1.38.0 (625451e37 2019-09-23)
╭ kerberos@kmacbookh   ~ 
╰ rls --version
rls 1.38.0 (7b0a20b 2019-08-11)
╭ kerberos@kmacbookh   ~ 
╰ rustfmt --version
rustfmt 1.4.4-stable (0462008d 2019-08-06)
#+END_EXAMPLE

** 安装编辑器

推荐使用 =Visual-Studio-Code= 作为 Rust 的编辑器，既有语法高亮，配合一些 Rust 插
件还能进行智能提示以及调试，还是相当舒心的。

#+BEGIN_EXAMPLE
brew cask install visual-studio-code
code --install-extension Swellaby.rust-pack
code --install-extension vadimcn.vscode-lldb
code --install-extension formulahendry.code-runner
#+END_EXAMPLE

- 安装 =Visual Studio Code=
- 安装 =Rust Extension Pack= 插件。
- 安装 =CodeLLDB= 插件。
- 安装 =Code Runner= 插件。

比较正式的项目用 =cargo new --bin tutor01= 这种方式合适一点，但是学习的话，都是
一些简短的样例代码，用 =cargo= 来创建就有些臃肿，不如直接用 =CodeRunner= 跑单个
文件好。

** 创建学习目录
我打算在 =~/ws/playground/rust= 目录下进行学习并且编写实验性质的代码：

#+BEGIN_EXAMPLE
mkdir -p ~/ws/playgroud/rust
cd ~/ws/playground/rust
#+END_EXAMPLE

由于 =rustup= 可以根据项目指定不同的工具链版本，这里我们就使用 =stable=:
#+BEGIN_EXAMPLE
echo "stable" > rust-toolchain
#+END_EXAMPLE
在 =rust-toolchain= 文件中显示指明我们使用 =stable= 的工具链（尽管前面我们仅仅安
装了 =stable= 工具链）如果以后你的系统工具链安装成 =nightly= 的话，也不会影响这
个工程。相反，如果你想实验某些 =nightly= 的功能的话，完全可以另外开辟一个目录，
并在其中创建 =rust-toolchain= 文件，在里面声明 =nightly= 工具链的版本即可。

说了这么多，最后我们以经典的 =hello world= 来结束这么繁琐的设置工作，以证明我们
终于可以开始写代码了！
#+BEGIN_EXAMPLE
cd ~/ws/playground/rust && code .
#+END_EXAMPLE
新建一个文件叫做 =hello.rs= (所有 Rust 的源文件的扩展名都是 =rs=). 输入源代码:
#+BEGIN_SRC rust
fn main() {
    println!("Hello, World");
}
#+END_SRC
点击 =CodeRunner= 的运行按钮，就看到 VSCode 的输出了。

#+CAPTION: rust hello world
#+ATTR_ORG: :width 512
#+ATTR_HTML: :width 512
[[file:rust-hello-world.jpg]]
