#+TITLE: 陪老 K 学 Rust
#+STARTUP: inlineimages content
#+AUTHOR: Evilee
#+OPTIONS: creator:t toc:nil num:t
#+PROPERTY: header-args :eval no
#+LANGUAGE: zh-CN
#+HUGO_BASE_DIR: ../../../
#+HUGO_AUTO_SET_LASTMOD: f
#+HUGO_SECTION: blog
#+HUGO_CATEGORIES: 计算机
#+HUGO_CUSTOM_FRONT_MATTTER: :authorbox true :comments true :toc false :mathjax true
#+HUGO_DRAFT: false
#+HUGO_WEIGHT: auto
#+HUGO_TAGS: Rust
* TODO 陪老 K 学 Rust
** Trait 和面向对象
** 函数式编程
* TODO 陪老 K 学 Rust (十四)
:PROPERTIES:
:EXPORT_DATE: 2020-01-09
:EXPORT_FILE_NAME: learn-rust-with-k-part14
:END:
错误处理
<!--more-->

* TODO 陪老 K 学 Rust (十三)
:PROPERTIES:
:EXPORT_DATE: 2020-01-09
:EXPORT_FILE_NAME: learn-rust-with-k-part13
:END:
迭代
<!--more-->

* TODO 陪老 K 学 Rust (十二)
:PROPERTIES:
:EXPORT_DATE: 2020-01-09
:EXPORT_FILE_NAME: learn-rust-with-k-part12
:END:
波动拳和 ~guard~
<!--more-->

* TODO 陪老 K 学 Rust (十一)
:PROPERTIES:
:EXPORT_DATE: 2020-01-16
:EXPORT_FILE_NAME: learn-rust-with-k-part11
:END:
~Result~ 枚举
<!--more-->

~Option~ 可以帮助开发者解决 =空值= 问题，但是 =空值= 并不能帮开发者进行错误处理，
在绝大部分情况下，一旦代码出错，开发者需要根据错误的详细信息进行处理，做现场恢复
还是使用备选方案，亦或进行日志输出以帮助解决问题。 这些方案，用 =空值= 是无法满
足需求的。

但假如把 ~Option~ 的 ~None~ 替换成具体的错误信息 ~Err~,开发人员根据 ~Err~ 来进行
错误处理，这样 ~Result~ 这个枚举就诞生了。形如：
#+BEGIN_SRC rust
enum Result<T,E> {
    Ok(T),
    Err(E),
}
#+END_SRC
当然，针对 ~Option~ 的 ~unwrap~ 和 ~unwrap_or~ 等就不能用于 ~Result~ 了。

Rust 中并没有 ~Exception~ 机制，函数的出错全靠 ~Result~ 来进行判断，这样就要求开
发者：

1. 永远不要调用 ~panic~, 给调用你 API 的开发者以处理的机会。
2. 永远不要调用导致 ~panic~ 的代码，如 ~unwrap~.
3. 如果可能，函数尽量使用 ~Result~ 作为返回值，以方便其他开发者处理。

* DONE 陪老 K 学 Rust (十)
:PROPERTIES:
:EXPORT_DATE: 2020-01-16
:EXPORT_FILE_NAME: learn-rust-with-k-part10
:END:
~Option~ 枚举
<!--more-->

~Option~ 是一个枚举，虽然在实现上，其并无特殊之处，但是在地位上，它和 ~Result~
都比较特殊，以至于 Rust 都对其制作了一些语法糖来方便开发者使用。

~Option~ 的诞生是为了解决空值问题。我们知道，在 C/C++ 甚至 Java, Javascript 中，
开发者都面临者 =空值= 问题带来的挑战。在 C/C++ 里，开发者需要小心处理 =空指针=,
但是仍然难以避免出现错误，以至于后来部分语言都弃用了 =指针= 这个数据类型。不幸的
是，即使如此，Javasript 还需要面对 =空值= 的问题。

Rust 中对于 =空值= (不仅仅是空指针), 吸收了其他某些语言（haskell?）的优点，引入
了 ~Option~ 这种处理方式，简而言之，就是一个新的枚举类型，要么它是一个空值，要么
它是一个具体的值。通过使用时需要强制解包（unwrap）来规范开发者使用的策略，避免出
现空值引发的错误。

#+BEGIN_SRC rust
enum Option<T> {
    None,
    Some(T),
}
#+END_SRC

以上示意代码就是 ~Option~ 的定义，其中 ~Option<T>~ 使用了 =泛型= 语法。 以下代码
是 ~Option~ 的一个非常典型的应用场景。
#+BEGIN_SRC rust
fn division(dividend: i32, divisor: i32) -> Option<i32> {
    if divisor == 0 {
        None
    } else {
        Some(dividend / divisor)
    }
}

fn main() {
    let r1 = division(4, 2);
    println!("4 / 2 = {:?}", r1);
    let r0 = division(4, 0);
    println!("4 / 2 = {:?}", r0);

    match r1 {
        None => {
            println!("r1 is None");
        },
        Some(value) => {
            println!("r1's value is: {}", value);
        }
    }

    println!("r1's value is: {}", r1.unwrap());
    println!("r0's value is: {}", r0.unwrap());
}
#+END_SRC
运行输出：
#+BEGIN_EXAMPLE
4 / 2 = Some(2)
4 / 2 = None
r1's value is: 2
r1's value is: 2
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/libcore/option.rs:378:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
#+END_EXAMPLE

divison 函数对输入的两个 ~i32~ 的值进行除法操作，并返回结果。如果我们在 C 语言中，
会如何处理呢？我们需要输出两个值：一个值表示输入是否有效，另外一个值表示输出的结
果。并且需要对返回值的有效性进行判断，因为一旦忘记有效性的判断，就引发逻辑性的错
误（因为 ret 的值是无效的）。
#+BEGIN_SRC c
#include<stdio.h>
int division(int dividend, int divisor, int* result) {
    if (divisor == 0) {
        return -1;
    }
    if (result) {
        *result = dividend / divisor;
    }

    return 0;
}

int main() {
    int ret;
    int err;
    err = division(4, 2, &ret);
    if (err < 0) {
        printf("divid zero!\n");
    } else {
        printf("4 / 2 = %d\n", ret);
    }

    err = division(4, 0, &ret);
    if (err < 0) {
        printf("divid zero!\n");
    } else {
        printf("4 / 0 = %d\n", ret);
    }
}
#+END_SRC

对于 Rust 而言，不进行 ~unwrap~ 或者 模式匹配是无法进行下一步操作的，故而对于开
发者来说，是相对安全的。

~unwrap~ 操作是解出 ~Option~ 里面的值，如果 ~Option~ 是空值，则会引发 ~panic~ 从
而导致程序崩溃。 ~unwrap~ 通常用在对于质量不高或者简短的示例代码中，在这些代码中，
我们通常不太关注错误，但是在实际的产品级别的代码中，需要小心对 ~Option~ 值进行检
查或者模式匹配。 除了模式匹配， Rust 还提供了一些更方便的函数来处理 ~Option~ 值。
1. ~unwrap_or~ : 如果是 ~None~ 则赋予一个默认值。
2. ~unwrap_or_default~: 如果是 ~None~ 则赋予类型的缺省值。
#+BEGIN_SRC rust
fn division(dividend: i32, divisor: i32) -> Option<i32> {
    if divisor == 0 {
        None
    } else {
        Some(dividend / divisor)
    }
}

fn main() {
    let r1 = division(4, 2);
    println!("4 / 2 = {:?}", r1);
    let r0 = division(4, 0);
    println!("4 / 2 = {:?}", r0);

    match r1 {
        None => {
            println!("r1 is None");
        },
        Some(value) => {
            println!("r1's value is: {}", value);
        }
    }

    println!("r1's value is: {}", r1.unwrap());
    println!("r0's unwrap_or: {}", r0.unwrap_or(-1));
    println!("r0's unwrap_or_default: {}", r0.unwrap_or_default());
}
#+END_SRC

老使用 ~unwrap~ 和 ~match~ 系列的确挺影响心情的，代码上也不好看，还有一种 =函数
式= 的链式调用处理方式比较符合正常的心智模型，在以后学习到 Rust 的 =函数式= 特性
时再明确。

* DONE 陪老 K 学 Rust (九)
:PROPERTIES:
:EXPORT_DATE: 2020-01-09
:EXPORT_FILE_NAME: learn-rust-with-k-part9
:END:
枚举。
<!--more-->

** 基本形式
经典形式
#+BEGIN_SRC rust
enum Direction {
    North,
    East,
    Sourth,
    West,
}
#+END_SRC

元组形式关联值：
#+BEGIN_SRC rust
enum NonamedShape {
    Square(u32),
    Rectangle(u32, u32),
    Circle(u32),
}
#+END_SRC

记录形式关联值：
#+BEGIN_SRC rust
enum NamedShape {
    Square {
        width: u32,
    },
    Rectangel {
        width: u32,
        height: u32,
    },
    Circle {
        radio: u32,
    },
}
#+END_SRC

经典形式可以当作是元组形式的特殊形式，毕竟 src_rust[:exports code]{struct
NoFieldTuple;} 是src_rust[:exports code]{struct NoField ();} 的简写。

混合形式，不同形式的类型结构可以混合起来组成单一的枚举类型。
#+BEGIN_SRC rust
enum HybridShape {
    Dot,
    Square(u32),
    Rectangle {
        width: u32,
        height: u32
    },
    Circle(u32),
}
#+END_SRC
** 解构
#+BEGIN_SRC rust
enum NamedShape {
    Square {
        width: u32,
    },
}

fn main() {
    let NamedShape::Square{width} = NamedShape::Square{width: 14};
    println!("width: {}", width);
}
#+END_SRC
运行输出:
#+BEGIN_EXAMPLE
width: 14
#+END_EXAMPLE

因为 ~NamedShape~ 只有一种情况： ~Square~, 所以可以正常解构到 ~width~ 变量上。但
是如果 ~NamedShape~ 有多种情况，会发生什么呢？
#+BEGIN_SRC rust
enum NamedShape {
    Square {
        width: u32,
    },
    Rectangle {
        width: u32,
        height: u32
    },
}

fn main() {
    let NamedShape::Square{width} = NamedShape::Square{width: 14};
    println!("width: {}", width);
}
#+END_SRC
编译报错：
#+BEGIN_EXAMPLE
error[E0005]: refutable pattern in local binding: `Rectangle { .. }` not covered
  --> r43.rs:12:9
   |
1  | / enum NamedShape {
2  | |     Square {
3  | |         width: u32,
4  | |     },
5  | |     Rectangle {
   | |     --------- not covered
...  |
8  | |     },
9  | | }
   | |_- `NamedShape` defined here
...
12 |       let NamedShape::Square{width} = NamedShape::Square{width: 14};
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Rectangle { .. }` not covered
   |
   = note: `let` bindings require an "irrefutable pattern", like a `struct` or an `enum` with only one variant
   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
help: you might want to use `if let` to ignore the variant that isn't matched
   |
12 |     if let NamedShape::Square{width} = NamedShape::Square{width: 14} { /* */ }
   |

error[E0381]: borrow of possibly-uninitialized variable: `width`
  --> r43.rs:13:27
   |
13 |     println!("width: {}", width);
   |                           ^^^^^ use of possibly-uninitialized `width`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0005, E0381.
For more information about an error, try `rustc --explain E0005`.
#+END_EXAMPLE

所以对枚举进行解构不能象对元组或者结构一样进行，必须先进行模式匹配，确定数据的类
型结构，再进行解构或者绑定。
** 模式匹配与解构
使用 ~match~ 进行模式匹配：
#+BEGIN_SRC rust
#[derive(Debug)]
enum HybridShape {
    Square(u32),
    Rectangle{ width:u32, height:u32},
    Circle(u32),
}

fn main() {
    use HybridShape::*;
    let shape = Rectangle{width: 20, height: 40};
    match shape {
        Square(width) => {
            println!("match square, width: {}", width);
        },
        Rectangle{width, height} => {
            println!("match Rectangle{{width: {}, height: {}}}", width, height);
        },
        Circle(radio) => {
            println!("match Circle(u32), radio: {}", radio);
        }
    }
}
#+END_SRC

运行输出：
#+BEGIN_EXAMPLE
warning: variant is never constructed: `Square`
 --> r44.rs:3:5
  |
3 |     Square(u32),
  |     ^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: variant is never constructed: `Circle`
 --> r44.rs:5:5
  |
5 |     Circle(u32),
  |     ^^^^^^^^^^^

match Rectangle{width: 20, height: 40}
#+END_EXAMPLE

#+BEGIN_QUOTE
src_rust[:exports code]{use HybridShape::*} 这句代码是在函数 ~main~ 中引入
~HybridShape~ 的名字空间，否则我们使用 ~HybridShape~ 的内部类型时需要显式指明，
如 ~HybridShape::Square~, ~HybridShape::Rectangle~ 等。
#+END_QUOTE


#+BEGIN_QUOTE
因为直接使用 src_rust[:exports code]{Rectangle{width: 20, height:40}} 构造的
~shape~, 故而编译器可以检测出其具体类型为 ~HybridShape::Rectangle~, 警告我们第三
行和第 5 行 ~Square~ 和 ~Circle~ 这两种类型的变体是从来不会被匹配到的，这里只是
演示代码，所以忽略即可。
#+END_QUOTE
** 模式匹配与绑定
在匹配的同时进行绑定：
#+BEGIN_SRC rust
#[derive(Debug)]
enum HybridShape {
    Square(u32),
    Rectangle{ width:u32, height:u32},
    Circle(u32),
}

fn main() {
    use HybridShape::*;
    let shape = Circle(50);
    match shape {
        Square(width) => {
            println!("match square, width: {}", width);
        },
        Rectangle{width, height} => {
            println!("match Rectangle{{width: {}, height: {}}}", width, height);
        },
        Circle(radio @ 0..=100) => {
            println!("match Circle(u32 @ 0..=100), radio: {}", radio);
        }
        Circle(radio) => {
            println!("match Circle(u32), radio: {}", radio);
        }
    }
}
#+END_SRC
运行输出：
#+BEGIN_EXAMPLE
 --> r45.rs:3:5
  |
3 |     Square(u32),
  |     ^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: variant is never constructed: `Rectangle`
 --> r45.rs:4:5
  |
4 |     Rectangle{ width:u32, height:u32},
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

match Circle(u32 @ 0..=100), radio: 50
#+END_EXAMPLE
同前一段代码类似，忽略警告。
* DONE 陪老 K 学 Rust (八)
:PROPERTIES:
:EXPORT_FILE_NAME: learn-rust-with-k-part8
:END:
自定义数据类型：结构体
<!--more-->
Rust 的结构体和枚举有一些新的特性，主要涉及到关联值、解构，模式匹配和解构。
使用结构体是 Rust 中定义新数据类型的唯一方式，结构体的定义方式有两种：
1. 元组形式
2. 记录形式
除了可以访问内部字段以外，两种结构体都支持解构其字段（如果有的话）。

** 基本形式
元组和记录形式的基本定义和基本访问形式见如下代码段。
#+CAPTION: struct 的基本形式
#+BEGIN_SRC rust
#[derive(Debug)]
struct NoFieldTuple;

#[derive(Debug)]
struct OneFieldTuple(i32);

#[derive(Debug)]
struct TwoFieldTuple(i32, u32);

#[derive(Debug)]
struct OneFieldRecord {
    index: u32,
}

#[derive(Debug)]
struct TwoFieldRecord {
    index: u32,
    value: i32,
}

fn main() {
    let no_field_tuple = NoFieldTuple;
    println!("{:?}", no_field_tuple);
    let one_field_tuple = OneFieldTuple(1);
    println!("{:?}", one_field_tuple);
    let mut two_field_tuple = TwoFieldTuple(2, 3);
    println!("{:?}", two_field_tuple);
    two_field_tuple.0 = 4;
    two_field_tuple.1 = 5;
    println!("{:?}", two_field_tuple);

    let one_field_record = OneFieldRecord{index: 0};
    println!("{:?}", one_field_record);
    let mut two_field_record = TwoFieldRecord{index: 1, value: 3,};
    println!("{:?}", two_field_record);
    two_field_record.value = 4;
    println!("{:?}", two_field_record);
}
#+END_SRC

#+CAPTION: 运行输出
#+BEGIN_EXAMPLE
NoFieldTuple
OneFieldTuple(1)
TwoFieldTuple(2, 3)
TwoFieldTuple(4, 5)
OneFieldRecord { index: 0 }
TwoFieldRecord { index: 1, value: 3 }
TwoFieldRecord { index: 1, value: 4 }
#+END_EXAMPLE

元组和记录的区别：
1. 元组形式可以用空元组来定义结构，而记录形式不可以。
2. 元组使用索引来访问字段，记录使用标签来访问字段。

** 解构
理解了元组的解构以后，元组结构的解构就比较容易理解了，一一对应即可。
#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

struct Foobar(i32, u32);
struct Greet {
    f1: i32,
    f2: u32,
}

fn main() {
    let foobar0 = Foobar(1, 2);
    let Foobar(x, y) = foobar0;
    print_type_of(&x);
    print_type_of(&y);

    let greet0 = Greet{f1: 1, f2: 2};
    let Greet{f1: v1, f2: v2} = greet0;
    print_type_of(&v1);
    print_type_of(&v2);

    let greet1 = Greet{f1: 3, f2: 4};
    let Greet{f1: f1, f2: f2} = greet1;
    print_type_of(&f1);
    print_type_of(&f2);

    let greet1 = Greet{f1: 5, f2: 6};
    let Greet{f1, f2} = greet1;
    print_type_of(&f1);
    print_type_of(&f2);
}
#+END_SRC

编译输出和运行输出：
#+BEGIN_EXAMPLE
warning: the `f1:` in this pattern is redundant
  --> r35.rs:23:15
   |
23 |     let Greet{f1: f1, f2: f2} = greet1;
   |               ---^^^
   |               |
   |               help: remove this
   |
   = note: `#[warn(non_shorthand_field_patterns)]` on by default

warning: the `f2:` in this pattern is redundant
  --> r35.rs:23:23
   |
23 |     let Greet{f1: f1, f2: f2} = greet1;
   |                       ---^^^
   |                       |
   |                       help: remove this

i32
u32
i32
u32
i32
u32
i32
u32
#+END_EXAMPLE

元组形式的解构和记录形式的解构形式上是类似的。

#+BEGIN_QUOTE
对于记录形式的结构，在字段名称和解构变量名称一致的情况下，src_rust[:exports code]{let Greet{f1: f1, f2: f2} = greet1;} 这种形式简写为：
src_rust[:exports code]{let Greet{f1, f2} = greet1;}
#+END_QUOTE

#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

struct Foobar(i32, u32);
struct Greet {
    f1: i32,
    f2: u32,
}

fn main() {
    let mut foobar = Foobar(1, 2);
    let Foobar(mut e1, ref mut e2) = foobar;
    println!("e1: {}, e2: {}", e1, e2);
    print_type_of(&e1);
    print_type_of(&e2);
    e1 = 0;
    println!("new e1: {}", e1);

    let greet = Greet{f1: 3, f2: 4};
    let Greet{ref f1, mut f2} = greet;
    println!("f1: {}, f2: {}", f1, f2);
    f2 = 0;
    println!("new f2: {}", f2);
}
#+END_SRC

运行输出:
#+BEGIN_EXAMPLE
e1: 1, e2: 2
i32
&mut u32
new e1: 0
f1: 3, f2: 4
new f2: 0
#+END_EXAMPLE

#+BEGIN_QUOTE
1. 元组结构使用 ~Type()~ 的方式解构，与构造时的语法对应。
2. 记录结构使用 ~Type{}~ 的方式解构，与构造时的语法对应。
#+END_QUOTE

** 模式匹配与解构
#+BEGIN_QUOTE
1. 元组结构使用 ~()~ 进行匹配和解构，与构造时的语法对应。
2. 记录结构使用 ~{}~ 进行匹配和解构，与构造时的语法对应。
#+END_QUOTE
#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

struct Foobar(i32, u32);
struct Greet {
    f1: i32,
    f2: u32,
}

fn main() {
    let foobar = Foobar(0, 1);

    match foobar {
        Foobar(ref x0, y@0..=1) => {
            println!("match Foobar(ref x0, y@0..1) x0 is: {}, y1 is: {}", x0, y);
        },
        Foobar(_, y1) if y1 == 2 => {
            println!("match Foobar(_, y1) if y1 == 2, y1 is: {}", y1);
            print_type_of(&y1);
        },
        _ => {
            println!("default match");
        },
    }

    let greet = Greet{f1: 2, f2: 4};
    match greet {
        Greet{f1: v1, f2: v2} => {
            println!("match Greet{{f1: v1, f2: v2}}, v1: {}, v2: {}", v1, v2);
            print_type_of(&v1);
            print_type_of(&v2);
        },
    }

    let greet = Greet{f1: 5, f2: 6};
    match greet {
        Greet{f1, f2} => {
            println!("match Greet{{f1, f2}}, f1: {}, f2: {}", f1, f2);
            print_type_of(&f1);
            print_type_of(&f2);
        },
    }

    let greet = Greet{f1: 7, f2: 8};
    match greet {
        Greet{f1, f2} if f1 < 0 => {
            println!("match Greet{{f1, f2}}, f1: {}, f2: {}", f1, f2);
            print_type_of(&f1);
            print_type_of(&f2);
        },
        _ => {
            println!("match _");
        }
    }

    let greet = Greet{f1: 7, f2: 8};
    match greet {
        Greet{f1: v0@ 0..= 10, f2: v1 @ 0 ..= 10} => {
            println!("match Greet{{f1, f2}}, f1: {}, f2: {}", v0, v1);
            print_type_of(&v0);
            print_type_of(&v1);
        },
        _ => {
            println!("match _");
        }
    }
}
#+END_SRC

运行输出:
#+BEGIN_EXAMPLE
match Foobar(ref x0, y@0..1) x0 is: 0, y1 is: 1
match Greet{f1: v1, f2: v2}, v1: 2, v2: 4
i32
u32
match Greet{f1, f2}, f1: 5, f2: 6
i32
u32
match _
match Greet{f1, f2}, f1: 7, f2: 8
i32
u32
#+END_EXAMPLE

** 模式匹配与绑定
在使用 ~@~ 绑定时，记录结构必须重新绑定新的变量名称。
#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

struct Greet {
    f1: i32,
    f2: u32,
}

fn main() {
    let greet = Greet{f1: 1, f2: 2};
    match greet {
        Greet{f1@0..=10, f2@0..=10} => {
            println!("match Greet{{f1, f2}}, f1: {}, f2: {}", f1, f2);
            print_type_of(&f1);
            print_type_of(&f2);
        },
        _ => {

        },
    }
}
#+END_SRC
编译错误:
#+BEGIN_EXAMPLE
error: expected `,`
  --> r42.rs:13:15
   |
13 |         Greet{f1@0..=10, f2@0..=10} => {
   |               ^^

error[E0425]: cannot find value `f1` in this scope
  --> r42.rs:14:63
   |
14 |             println!("match Greet{{f1, f2}}, f1: {}, f2: {}", f1, f2);
   |                                                               ^^ not found in this scope

error[E0425]: cannot find value `f2` in this scope
  --> r42.rs:14:67
   |
14 |             println!("match Greet{{f1, f2}}, f1: {}, f2: {}", f1, f2);
   |                                                                   ^^ not found in this scope

error[E0425]: cannot find value `f1` in this scope
  --> r42.rs:15:28
   |
15 |             print_type_of(&f1);
   |                            ^^ not found in this scope

error[E0425]: cannot find value `f2` in this scope
  --> r42.rs:16:28
   |
16 |             print_type_of(&f2);
   |                            ^^ not found in this scope

error: aborting due to 5 previous errors

For more information about this error, try `rustc --explain E0425`.
#+END_EXAMPLE

* DONE 陪老 K 学 Rust (七)
:PROPERTIES:
:EXPORT_FILE_NAME: learn-rust-with-k-part7
:EXPORT_DATE: 2020-01-07
:END:
元组可以说是 Rust 最简单的自定类型。通过元组来理解 =模式匹配= 和 =解构= -现代语言的时尚
特性。
<!--more-->

解构 (destruct) 是指把值从某些解构中提取出来，并且绑定到新的变量上。为了更好得理
解解构，我们写一个辅助性的函数 ~print_type_of~ 来打印变量的类型，并且使用最简单
的 =元组= 来进行演示.
#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}
#+END_SRC

** 解构的基本形式
#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let (x, y, z) = (0, 1, 2);
    print_type_of(&x);
    print_type_of(&y);
    print_type_of(&z);
    println!("x:{}, y:{}, z:{}", x, y, z);
}
#+END_SRC
运行输出：
#+BEGIN_EXAMPLE
i32
i32
i32
x:0, y:1, z:2
#+END_EXAMPLE

不关心的解构字段用 ~_~ 或者 ~..~ 进行占位，如：
#+BEGIN_SRC rust
fn main() {
    let (x, _, z) = (0, 1, 2);
    println!("x:{}, z:{}", x, z);
    let (x, ..) = (3, 4, 5);
    println!("x:{}", x);
    let (.., z) = (6, 7, 8, 9);
    println!("z:{}", z);
    let (.., y, z) = (10, 11, 12, 13, 14);
    println!("y: {}, z:{}", y, z);
}
#+END_SRC
运行输出:
#+BEGIN_EXAMPLE
x:0, z:2
x:3
z:9
y: 13, z:1
#+END_EXAMPLE


#+BEGIN_QUOTE
解构要诀：
1. 使用 ~let~, ~=~ 左右两边的类型一致。
2. 使用 ~_~ 作为占位符忽略 1 个匹配字段。
3. 使用 ~..~ 作为占位符忽略首尾多个字段。
4. 在一个解构中不能使用多个 ~..~ 进行字段忽略，因为有语义歧义。
#+END_QUOTE

由于变量数量不足而引起的类型不匹配：
#+BEGIN_SRC rust
fn main() {
    let (x, y) = (0, 1, 2);
    println!("x:{}, y:{}", x, y);
}
#+END_SRC
编译报错：
#+BEGIN_EXAMPLE
error[E0308]: mismatched types
 --> r28.rs:2:9
  |
2 |     let (x, y) = (0, 1, 2);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected type `({integer}, {integer}, {integer})`
             found type `(_, _)`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`
#+END_EXAMPLE
#+BEGIN_QUOTE
有些编程语言在解构变量数量不足时，最后一个变量会解构所有剩余的元组元素，从而变成一个
元组，但是 Rust 不会。
#+END_QUOTE

** 解构出可变绑定
#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let (x, mut y, z) = (0, 1, 2);
    print_type_of(&x);
    print_type_of(&y);
    print_type_of(&z);
    println!("x:{}, y:{}, z:{}", x, y, z);
    y = 4;
    println!("{:}", y);
}
#+END_SRC

运行输出
#+BEGIN_EXAMPLE
i32
i32
i32
x:0, y:1, z:2
4
#+END_EXAMPLE

** 解构出引用
#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let (x, *y, z) = (0, 1, 2);
    print_type_of(&x);
    print_type_of(&y);
    print_type_of(&z);
    println!("x:{}, y:{}, z:{}", x, y, z);
}
#+END_SRC

我们妄图使用 ~*y = i32~ 的形式解构出一个 ~&i32~, 编译器报错：
#+BEGIN_EXAMPLE
error: expected pattern, found `*`
 --> r28.rs:2:13
  |
2 |     let (x, *y, z) = (0, 1, 2);
  |             ^ expected pattern

error: aborting due to previous error
#+END_EXAMPLE
???, 原来想解构出 =引用= 的语法形式是 ~ref~, 为什么 *不是* ~*x~ 的形式？

#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let (x, ref y, z) = (0, 1, 2);
    print_type_of(&x);
    print_type_of(&y);
    print_type_of(&z);
    println!("x:{}, y:{}, z:{}", x, y, z);
}
#+END_SRC

运行输出:
#+BEGIN_EXAMPLE
i32
&i32
i32
x:0, y:1, z:2
#+END_EXAMPLE

如果要解构出一个 ~ref mut~ 呢？
#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let (x, ref mut y, z) = (0, 1, 2);
    print_type_of(&x);
    print_type_of(&y);
    print_type_of(&z);
    println!("x:{}, y:{}, z:{}", x, y, z);
}
#+END_SRC
运行输出:
#+BEGIN_EXAMPLE
i32
&mut i32
i32
x:0, y:1, z:
#+END_EXAMPLE

如果要解构出一个 ~mut ref~ 呢？
#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let (x, mut ref y, z) = (0, 1, 2);
    print_type_of(&x);
    print_type_of(&y);
    print_type_of(&z);
    println!("x:{}, y:{}, z:{}", x, y, z);
}
#+END_SRC
不要太想当然 :(, 编译器报错。
#+BEGIN_EXAMPLE
error: the order of `mut` and `ref` is incorrect
 --> r29.rs:6:13
  |
6 |     let (x, mut ref y, z) = (0, 1, 2);
  |             ^^^^^^^ help: try switching the order: `ref mut`

error: aborting due to previous error
#+END_EXAMPLE

** 嵌套解构
当然解构也可以嵌套的，也就是可以解构出内层的元组的元素。
#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let tuple = (1, 2, 3, 4, (10, 11, 12, 13));
    let (.., (x,..)) = tuple;
    println!("x: {}", x);
    print_type_of(&x);
}
#+END_SRC

运行输出:
#+BEGIN_EXAMPLE
x: 10
i3
#+END_EXAMPLE

** 绑定与解构
从形式的一致性来说： ~let p = &mut x;~ 这种绑定也符合 =解构= 的一般形式。

#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let mut v = 10;
    print_type_of(&v);
    let p = &v;
    print_type_of(&p);
    let ref p = v;
    print_type_of(&p);
    let ref mut p = v;
    print_type_of(&p);
}
#+END_SRC

运行输出:
#+BEGIN_EXAMPLE
i32
&i32
&i32
&mut i32
#+END_EXAMPLE

** 解构与生命周期
假设一个元组由数个元素组成，如果进行解构的话，其所有权是否会被转移？答案是 *会*,
看代码：
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop (&mut self) {
        println!("Dropping {:?}", self);
    }
}

fn main() {
    let x = (Foobar(0), );
    let (foobar,) = x;
    println!("{:?}", foobar);
    println!("{:?}", x);
}
#+END_SRC
编译器报错：x 的所有权已经被转移。
#+CAPTION: 编译器报错
#+BEGIN_EXAMPLE
error[E0382]: borrow of moved value: `x`
  --> r33.rs:14:22
   |
12 |     let (foobar,) = x;
   |          ------ value moved here
13 |     println!("{:?}", foobar);
14 |     println!("{:?}", x);
   |                      ^ value borrowed here after partial move
   |
   = note: move occurs because `x.0` has type `Foobar`, which does not implement the `Copy` trait

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
#+END_EXAMPLE

如果使用引用解构的话，则不会，符合生命周期的心智模型。
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop (&mut self) {
        println!("Dropping {:?}", self);
    }
}

fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let x = (Foobar(0), );
    let (ref foobar,) = x;
    println!("{:?}", foobar);
    println!("{:?}", x);
    print_type_of(&x);
    print_type_of(&foobar);
}
#+END_SRC

#+CAPTION: 运行输出
#+BEGIN_EXAMPLE
Foobar(0)
(Foobar(0),)
(r34::Foobar,)
&r34::Foobar
Dropping Foobar(0)
#+END_EXAMPLE

** 模式匹配与解构
除了解构之外，元组还可以在使用 ~match~ 关键字进行模式匹配的同时进行解构。

#+CAPTION: 模式匹配和解构
#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let v = (0, 3);
    match v {
        (x, 1) => {
            print_type_of(&x);
            println!("match (x, 1)");
        },
        (x, 2) => {
            print_type_of(&x);
            println!("match (x, 2)");
        },
        (x, 3) => {
            print_type_of(&x);
            println!("match (x, 3)");
        },
        _ => {
            println!("not match any");
        }
    }
}
#+END_SRC

#+CAPTION: 运行输出
#+BEGIN_EXAMPLE
i32
match (x, 3)
#+END_EXAMPLE

#+BEGIN_QUOTE
注意使用 ~_~ 进行默认匹配来全覆盖匹配的所有分支。
#+END_QUOTE


#+CAPTION: 模式匹配与解构：引用（一）
#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let v = (0, 3);
    match &v {
        (x, 1) => {
            print_type_of(&x);
            println!("match (x, 1)");
        },
        (x, 2) => {
            print_type_of(&x);
            println!("match (x, 2)");
        },
        (x, 3) => {
            print_type_of(&x);
            println!("match (x, 3)");
        },
        _ => {
            println!("not match any");
        }
    }
}
#+END_SRC

#+CAPTION: 运行输出
#+BEGIN_EXAMPLE
&i32
match (x, 3)
#+END_EXAMPLE

使用 ~ref~ 来引用解构。

#+CAPTION: 模式匹配与解构：引用（二）
#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let v = (0, 3);
    match v {
        (ref x, 1) => {
            print_type_of(&x);
            println!("match (x, 1)");
        },
        (ref x, 2) => {
            print_type_of(&x);
            println!("match (x, 2)");
        },
        (ref x, 3) => {
            print_type_of(&x);
            println!("match (x, 3)");
        },
        _ => {
            println!("not match any");
        }
    }
}
#+END_SRC

#+CAPTION: 运行输出
#+BEGIN_EXAMPLE
&i32
match (x, 3)
#+END_EXAMPLE

#+BEGIN_QUOTE
注意以上两段代码的不同点。
#+END_QUOTE

如果要解构可变引用呢？

#+CAPTION: 模式匹配与解构：引用（三）
#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let mut v = (0, 3);
    match v {
        (ref mut x, 1) => {
            print_type_of(&x);
            println!("match (x, 1)");
        },
        (ref mut x, 2) => {
            print_type_of(&x);
            println!("match (x, 2)");
        },
        (ref mut x, 3) => {
            print_type_of(&x);
            println!("match (x, 3)");
        },
        _ => {
            println!("not match any");
        }
    }
}
#+END_SRC

#+CAPTION: 运行输出
#+BEGIN_EXAMPLE
&mut i32
match (x, 3)
#+END_EXAMPLE

** 模式匹配与条件解构
#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let v = (0, 1);
    match v {
        (x, y) if y > 0 && y <= 2 => {
            print_type_of(&x);
            println!("match (x, y >0 && y <=2)");
        },
        (x, 1) => {
            print_type_of(&x);
            println!("match (x, 1)");
        },
        (x, 3) => {
            print_type_of(&x);
            println!("match (x, 3)");
        },
        _ => {
            println!("not match any");
        }
    }
}
#+END_SRC

运行输出
#+CAPTION: 运行输出
#+BEGIN_EXAMPLE
i32
match (x, y >0 && y <=2)
#+END_EXAMPLE

#+BEGIN_QUOTE
1. 使用 ~if~ 来限定解构条件，本例子中是 src_rust[:exports code]{if y> 0 &&
   y<=2}.
2. 模式匹配是从上到下进行匹配测试的，一旦满足测试条件，则不再进行匹配测试。本例
   子中的 ~(0, 1)~ 虽然满足前两个测试分支，但是 ~(x, 1)~ 匹配分支不会被执行。
3. 由于语义的限制，条件解构需要使用 ~_~ 来达到全覆盖的效果。
#+END_QUOTE

** 模式匹配与绑定
在模式匹配情况下，也可以使用 ~@~ 在匹配的同时绑定。

#+BEGIN_SRC rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let v = (0, 1);
    match v {
        (x, y @ 0..=2) => {
            print_type_of(&x);
            print_type_of(&y);
            println!("y is: {}", y);
            println!("match (x, y @ 0 ..= 2)");
        },
        (x, 1) => {
            print_type_of(&x);
            println!("match (x, 1)");
        },
        (x, 3) => {
            print_type_of(&x);
            println!("match (x, 3)");
        },
        _ => {
            println!("not match any");
        }
    }
}
#+END_SRC

运行输出：
#+BEGIN_EXAMPLE
warning: unreachable pattern
  --> r39.rs:14:9
   |
14 |         (x, 1) => {
   |         ^^^^^^
   |
   = note: `#[warn(unreachable_patterns)]` on by default

i32
i32
y is: 0
match (x, y @ 0 ..= 2)
#+END_EXAMPLE

看上去 ~@~ 和 ~if~ 区别不大，实际上，在某些情况下， ~@~ 是非常有用的：考虑我们
~match~ 的不是某个变量，而是某个函数的返回值，在满足条件的情况下，我们需要绑定这
个函数的返回值进行某些操作，而其他情况下，我们不使用它，也就没有必要绑定它。而且
使用 ~@~ 要比 ~if~ 简洁。

#+BEGIN_SRC rust
fn calculate_score() -> i32 {
    100
}

fn main() {
    match calculate_score() {
        0 ..= 59 => {
            println!("bad");
        },
        score @ 60..=100 => {
            println!("good, my score is: {}", score);
        },
        _ => {
            println!("invalid score");
        }
    }
}
#+END_SRC
#+BEGIN_SRC rust
fn calculate_score() -> i32 {
    100
}

fn main() {
    match calculate_score() {
        0 ..= 59 => {
            println!("bad");
        },
        score if score >= 60 && score <= 100 => {
            println!("good, my score is: {}", score);
        },
        _ => {
            println!("invalid score");
        }
    }
}
#+END_SRC

运行输出:
#+BEGIN_EXAMPLE
good, my score is: 100
#+END_EXAMPLE

* DONE 陪老 K 学 Rust (六)
:PROPERTIES:
:EXPORT_FILE_NAME: learn-rust-with-k-part6
:EXPORT_DATE: 2010-01-02
:END:
克隆和拷贝来了。
<!--more-->

** 从引用的所有权居然没有被转移开始
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn uses_foobar(foobar: &Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x = Foobar(0);
    let y = &x;
    uses_foobar(y);
    uses_foobar(y);
}
#+END_SRC

运行输出：
#+BEGIN_EXAMPLE
I consumed a Foobar: Foobar(0)
I consumed a Foobar: Foobar(0)
Dropping a Foobar: Foobar(0)
#+END_EXAMPLE

可以连续两次调用 ~uses_foobar~, 什么情况？不是说所有权会转移的吗？那变量 ~y~ 绑
定值（ ~x~ 的地址）的所有权不会被转移吗？

做一个简单的实验：
#+BEGIN_SRC rust
fn uses_i32(i: i32) {
    println!("I consumed an i32: {}", i);
}

fn main() {
    let x = 1;
    uses_i32(x);
    uses_i32(x);
}
#+END_SRC
运行输出：
#+BEGIN_EXAMPLE
I consumed an i32: 1
I consumed an i32: 1
#+END_EXAMPLE

在上述代码段中，难道 ~x~ 的所有权没有被转移？

再实验一下：
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

fn uses_foobar(foobar: Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x = Foobar(1);

    uses_foobar(x);
    uses_foobar(x);
}
#+END_SRC

编译报错：
#+BEGIN_EXAMPLE
error[E0382]: use of moved value: `x`
  --> l25.rs:12:17
   |
9  |     let x = Foobar(1);
   |         - move occurs because `x` has type `Foobar`, which does not implement the `Copy` trait
10 |
11 |     uses_foobar(x);
   |                 - value moved here
12 |     uses_foobar(x);
   |                 ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
#+END_EXAMPLE

仔细阅读错误输出， =move occurs because `x` has type `Foobar`, which does not
implement the `Copy` trait=, 看来是 ~Foobar~ 没有实现 ~Copy~ trait. 那基本可以确
定前面两段代码中的 ~y~ 可能已经实现了 ~Copy~ trait, 所以在编译期间才没有所有权转
移的报错信息。

Rust 中有一个特定的 trait: ~Copy~, 这个 trait 可以标识某些数据类型可以按值传递，
通常，基于效率方面的考虑，按值传递这种方式适合的数据类型在被复制的时候应该不能
浪费很多的资源。在上例中， ~i32~ 和 ~地址~ 这两种数据类型因为实现了 ~Copy~
trait, 在作为参数传递给函数时，实际上是拷贝了一个新的值给函数，函数所拥有的所有
权是被复制出来的新值的所有权。

对于 ~Foobar~ 数据结构，如果需要按值传递的话，可以显式使用 ~Clone~ trait.
#+BEGIN_SRC rust
#[derive(Debug, Clone)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(self: &mut Self) {
        println!("Dropping: {:?}", self);
    }
}

fn uses_foobar(foobar: Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x = Foobar(1);

    uses_foobar(x.clone());
    uses_foobar(x);
}
#+END_SRC
运行输出:
#+BEGIN_EXAMPLE
I consumed a Foobar: Foobar(1)
Dropping: Foobar(1)
I consumed a Foobar: Foobar(1)
Dropping: Foobar(1)
#+END_EXAMPLE

~Clone~ trait 和 ~Debug~ trait 一样，都是可以自动继承的。对于复合数据类型来说，
自动继承的条件是：组成复合数据类型的子数据类型必须满足 ~Clone~ trait.

对于 Rust 来说， ~Copy~ trait 必须实现 ~Clone~ trait. 这里并不是说 ~Copy~ trait
需要使用 ~Clone~ trait 的 ~clone~ 函数去复制对象，而是说可以 ~Copy~ 的对象是可以
被 ~Clone~ 的，实际上 ~Copy~ trait 是编译器在内存中按位复制一个新的值。 ~Copy~
trait 只是一个标志，内部没有需要实现的方法，这个标志存在意义在于告知编译器：我这
个数据类型是可以按值传递的，请在需要的时候 =按位复制= 一个新的值。既然有了
~Clone~, 为何不用 ~Clone~ 替代呢？因为在某些情况下，数据类型虽然实现了 ~Clone~,
但是 ~Clone~ 一个新值的代价非常大。

#+BEGIN_SRC rust
#[derive(Debug, Clone, Copy)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(self: &mut Self) {
        println!("Dropping: {:?}", self);
    }
}

fn uses_foobar(foobar: Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x = Foobar(1);

    uses_foobar(x);
    uses_foobar(x);
}
#+END_SRC

编译输出：
#+BEGIN_EXAMPLE
error[E0184]: the trait `Copy` may not be implemented for this type; the type has a destructor
 --> l26.rs:1:24
  |
1 | #[derive(Debug, Clone, Copy)]
  |                        ^^^^ Copy not allowed on types with destructors

error: aborting due to previous error

For more information about this error, try `rustc --explain E0184`
#+END_EXAMPLE

编译器报错： ~Copy~ trait 不能出现在具有 ~Drop~ trait 的数据类型上。 仔细想想也
有道理， ~Drop~ 是数据在销毁时的回收动作，如果一个数据类型在销毁时会有资源需要回
收，一方面说明它被复制时的消耗可能比较大，另一方面说明这个数据类型在使用时必然要
对所释放的资源进行初始化，编译器默认的 ~Copy~ 动作(=按位复制=)并不能初始化这些资
源，强行使用是不正确的。去掉 ~Drop~ trait 即可。
#+BEGIN_SRC rust
#[derive(Debug, Clone, Copy)]
struct Foobar(i32);

fn uses_foobar(foobar: Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x = Foobar(1);

    uses_foobar(x);
    uses_foobar(x);
}
#+END_SRC

结论：只有可以 =按位复制= 的数据类型才能实现 ~Copy~ trait. 能否按位复制，要看写
代码的人自己判断。通常可以按照以下几个规则进行：
1. 基本数据类型，整型，浮点型等。
2. 内部实现类型都可以 ~Copy~ 的复合数据类型。
3. 不需要初始化资源的类型，比如在堆上申请内存空间，打开文件描述符或者 socket 等。

** 引用和指针
回过头来，我们看看引用、借用的问题。变量 ~y~ 是 ~&mut Foobar~ 类型，这是一个引用，
也就是一个指针。这个值指向其所引用的值的地址，所以这个地址明显是可以 =按位复制=
的，其目标值如果需要初始化资源或者释放资源，则由目标值的属主负责处理，故而这里才
称之为 =借用=.

* DONE 陪老 K 学 Rust (五)
:PROPERTIES:
:EXPORT_FILE_NAME: learn-rust-with-k-part5
:EXPORT_DATE: 2019-12-26
:END:

可变与不变
<!--more-->

** 赋值与绑定

#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn uses_foobar(foobar: &Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let mut x = Foobar(0);
    let mut z = Foobar(1);
    let mut y = &mut x;
    uses_foobar(y);
    y.0 = 1;
    uses_foobar(y);

    y = &mut z;
    uses_foobar(y);
    y.0 = 3;
    uses_foobar(y);
}
#+END_SRC

在很多语言中（其实也包括 Rust）， ~let~ 的含义并不是声明一个变量，而是进行一个值 =绑定=
操作，也就是把一个值和一个名称关联起来，从这一点上来说 =绑定= 比 =赋值= 更形象。

** 可变与不变
还记得 C 关于 ~const~ 关键字的 =常量指针= 与 =指针常量= 的问题吗？src_c[:exports
code]{const char * const p = &str;}, 我们就以分析 ~const~ 的方法
来分析 ~mut~ 关键字:

1. src_rust[:exports code]{let mut x: Foobar = Foobar(0);} 这种形式中， ~mut~ 修
   饰的是绑定关系还是值本身？ ~mut~ 只修饰变量，即修饰变量和值的绑定关系，不修
   饰值本身。
2. src_rust[:exports code]{let mut y: &mut Foobar = &mut x;} 这种引用形式中，第
   一个 ~mut~ 限定的是绑定关系，也就是 ~y~ 可以是 ~x~ 的引用绑定，也可以是其他值
   的引用绑定。 第二个 ~mut~ 限定的是被应用的值本身，即值本身的内容是否可以被此
   引用修改。第三个 ~mut~ 的作用等同于第二个 ~mut~, 在使用类型推断的情况下，这一
   点就更为明显：src_rust[:exports code]{let mut y = &mut x;}.

*** 修改值
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    println!("{:?}", x);
    x.0 = 10;
    println!("{:?}", x);
}
#+END_SRC

编译输出:
#+BEGIN_EXAMPLE
  --> l20.rs:13:5
   |
11 |     let x = Foobar(0);
   |         - help: consider changing this to be mutable: `mut x`
12 |     println!("{:?}", x);
13 |     x.0 = 10;
   |     ^^^^^^^^ cannot assign

error: aborting due to previous error
#+END_EXAMPLE

结论：非 ~mut~ 绑定不能修改值的内容。

#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let mut x = Foobar(0);
    println!("{:?}", x);
    x.0 = 10;
    println!("{:?}", x);
}
#+END_SRC

编译运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(10)
Dropping a Foobar: Foobar(10
#+END_EXAMPLE
结论： ~mut~ 绑定可以修改值的内容。

*** 修改绑定关系
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    let y = Foobar(1);
    println!("{:?}", x);
    x = y;
    println!("{:?}", x);
}
#+END_SRC

编译输出：
#+BEGIN_EXAMPLE
error[E0384]: cannot assign twice to immutable variable `x`
  --> l20.rs:14:5
   |
11 |     let x = Foobar(0);
   |         -
   |         |
   |         first assignment to `x`
   |         help: make this binding mutable: `mut x`
...
14 |     x = y;
   |     ^ cannot assign twice to immutable variable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0384`
#+END_EXAMPLE

结论：非 ~mut~ 绑定不能修改绑定关系。

#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let mut x = Foobar(0);
    println!("{:?}", x);
    let y = Foobar(1);
    println!("{:?}", y);
    x = y;
    println!("{:?}", x);
    x.0 = 10;
    println!("{:?}", x);
}
#+END_SRC

编译运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(1)
Dropping a Foobar: Foobar(0)
Foobar(1)
Foobar(10)
Dropping a Foobar: Foobar(10)
#+END_EXAMPLE

结论： ~mut~ 绑定可以修改绑定关系，并且可以修改值的内容。这个修改与 ~y~ 原来是否
是 ~mut~ 无关。

*** 重置绑定
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    println!("{:?}", x);
    let x = Foobar(1);
    println!("{:?}", x);
}
#+END_SRC

编译运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(1)
Dropping a Foobar: Foobar(1)
Dropping a Foobar: Foobar(0
#+END_EXAMPLE

结论： 无论是否是 ~mut~ 绑定，都可以重新绑定。

*** 可变性修改
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    println!("{:?}", x);
    let mut y = x;
    println!("{:?}", y);
    y.0 = 1;
    println!("{:?}", y);
}
#+END_SRC

运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(0)
Foobar(1)
Dropping a Foobar: Foobar(1)
#+END_EXAMPLE

根据以上代码，下面的 mutable move 也就很好理解了。
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

fn main() {
    let x = Foobar(1);
    foo(x);
}

fn foo(mut x: Foobar) {

    x.0 = 2; // changes the 0th value inside the product

    println!("{:?}", x);
}
#+END_SRC

运行输出：
#+BEGIN_EXAMPLE
Foobar(2)
#+END_EXAMPLE

*** 不变引用不变值绑定
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    let y = &x; // let y: &Foobar = &x;
    println!("{:?}", x);
    println!("{:?}", y);
}
#+END_SRC

编译运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(0)
Dropping a Foobar: Foobar(0)
#+END_EXAMPLE

#+BEGIN_QUOTE
src_rust[:exports code]{println!("{:?}", x)} 难道不会接管 ~x~ 的所有权吗？注意：
println! 是宏而不是函数，你焉不知这个宏看上去是用的 ~x~, 在背后用的是 ~&x~ 呢？
#+END_QUOTE

*** 不变引用可变值绑定

#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let mut x = Foobar(0);
    println!("{:?}", x);
    let y = &mut x; // let y: &mut Foobar = &mut x;
    println!("{:?}", y);
    y.0 = 10;
    println!("{:?}", y);
}
#+END_SRC

编译运行输出:
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(0)
Foobar(10)
Dropping a Foobar: Foobar(10)
#+END_EXAMPLE

#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let mut x = Foobar(0);
    println!("{:?}", x);
    let y = &mut x; // let y: &mut Foobar = &mut x;
    println!("{:?}", y);
    let mut z = Foobar(1);
    y = &mut z;
    println!("{:?}", y);
}
#+END_SRC

编译报错：
#+BEGIN_EXAMPLE
error[E0384]: cannot assign twice to immutable variable `y`
  --> l20.rs:16:5
   |
13 |     let y = &mut x; // let y: &mut Foobar = &mut x;
   |         -
   |         |
   |         first assignment to `y`
   |         help: make this binding mutable: `mut y`
...
16 |     y = &mut z;
   |     ^^^^^^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0384`.
#+END_EXAMPLE

结论： ~y~ 是不变引用，其引用的值被 ~mut~ 修饰为可变。即： ~y~ 的绑定关系不能修
改，但是 ~y~ 指向的值可以被修改。

*** 可变引用不变值绑定
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    println!("{:?}", x);
    let mut y = &x; // let mut y: &Foobar = &mut x;
    println!("{:?}", y);
    let z = Foobar(1);
    y = &z;
    println!("{:?}", y);
}
#+END_SRC

运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(0)
Foobar(1)
Dropping a Foobar: Foobar(1)
Dropping a Foobar: Foobar(0)
#+END_EXAMPLE

结论：可变引用可以改变绑定关系， ~y~ 并不特殊，也遵循可变绑定和不变绑定。

*** 可变引用可变值绑定
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let mut x = Foobar(0);
    println!("{:?}", x);
    let mut y = &mut x; // let mut y: &Foobar = &mut x;
    println!("{:?}", y);
    let mut z = Foobar(1);
    y = &mut z;
    println!("{:?}", y);
}
#+END_SRC

运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(0)
Foobar(1)
Dropping a Foobar: Foobar(1)
Dropping a Foobar: Foobar(0)
#+END_EXAMPLE

结论：可变引用可以改变绑定关系， ~y~ 并不特殊，也遵循可变绑定和不变绑定。

*** 不变引用的共享性
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    let y = &x; // let y: &Foobar = &x;
    let z = &x; // let z: &Foobar = &x;
    println!("{:?}", x);
    println!("{:?}", y);
    println!("{:?}", z);
}
#+END_SRC
运行输出：
#+BEGIN_EXAMPLE
Foobar(0)
Foobar(0)
Foobar(0)
Dropping a Foobar: Foobar(0)
#+END_EXAMPLE

结论： ~x~, ~y~, ~z~ 随便用。

*** 可变引用的排他性
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let mut x = Foobar(0);
    let y = &mut x; // let y: &mut Foobar = &mut x;
    let z = &x; // let z: &Foobar = &x;
    println!("{:?}", x);
    println!("{:?}", y);
    println!("{:?}", z);
}
#+END_SRC

编译报错：
#+BEGIN_EXAMPLE
error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --> l20.rs:13:13
   |
12 |     let y = &mut x; // let y: &Foobar = &x;
   |             ------ mutable borrow occurs here
13 |     let z = &x; // let z: &Foobar = &x;
   |             ^^ immutable borrow occurs here
14 |     println!("{:?}", x);
15 |     println!("{:?}", y);
   |                      - mutable borrow later used here

error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --> l20.rs:14:22
   |
12 |     let y = &mut x; // let y: &Foobar = &x;
   |             ------ mutable borrow occurs here
13 |     let z = &x; // let z: &Foobar = &x;
14 |     println!("{:?}", x);
   |                      ^ immutable borrow occurs here
15 |     println!("{:?}", y);
   |                      - mutable borrow later used here

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0502`.
#+END_EXAMPLE

结论：
1. ~println!~ 宏的确是转换成了引用。
2. 在 ~y~ 可变借用了 ~x~, 以后， ~println!~ 的不变引用被拒绝。

*** 强制不变引用和强制可变引用
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let mut x = Foobar(0);
    let y = &x; // let y: &Foobar = &x;
    let z = &x; // let z: &Foobar = &x;
    println!("{:?}", x);
    println!("{:?}", y);
    println!("{:?}", z);
}
#+END_SRC

编译运行输出:
#+BEGIN_EXAMPLE
warning: variable does not need to be mutable
  --> l20.rs:11:9
   |
11 |     let mut x = Foobar(0);
   |         ----^
   |         |
   |         help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` on by default

Foobar(0)
Foobar(0)
Foobar(0)
Dropping a Foobar: Foobar(0)
#+END_EXAMPLE

除了一个 ~x~ 的未使用的 ~mut~ 限定意外，运行没毛病，也就是： *可以以不变的方式引
用可变绑定*. 那我们反过来，以可变的方式应用不变绑定呢？
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    let x = Foobar(0);
    let y = &mut x; // let y: &mut Foobar = &mut x;
    println!("{:?}", y);
}
#+END_SRC

编译报错：
#+BEGIN_EXAMPLE
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
  --> l20.rs:12:13
   |
11 |     let x = Foobar(0);
   |         - help: consider changing this to be mutable: `mut x`
12 |     let y = &mut x; // let y: &mut Foobar = &mut x;
   |             ^^^^^^ cannot borrow as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
#+END_EXAMPLE

结论： *不能* 把不变绑定强制转换成可变引用。

#+BEGIN_QUOTE
扩展一下思路，在函数参数传递的场景下， ~mut~ 的原则又是什么呢？
1. src_rust[:exports code]{fn uses_foobar(foobar: &Foobar)}
2. src_rust[:exports code]{fn uses_foobar(mut foobar: &Foobar)}
2. src_rust[:exports code]{fn uses_foobar(foobar: &mut Foobar)}
3. src_rust[:exports code]{fn uses_foobar(mut foobar: &mut Foobar)}
#+END_QUOTE

** 再论可变与不变

由以上的栗子可知： ~Foobar~ 自身完全没有权利决定自己的内容是可变的还是不变的，其内
容能否可变，取决于在其被绑定时的绑定方式。象 ~Foopbar~ 这种元组还不是特别明显，
以 ~struct~ 作为参考：

#+BEGIN_SRC rust
struct Greet {
    age: i32,
    score: i32
}

fn main() {
    let f1 = Greet{age: 18, score: 60};
    let mut f2 = Greeg{age: 20, score: 80};
}
#+END_SRC

在以上代码中，实际上 ~Greet~ 的字段都是默认可变的。:( 这听上去怎么和 Rust 的值默
认不变相矛盾？

在其他一些语言中， ~let~ 和 ~var~ 来分别代表不变绑定和可变绑定（如：swift），并
且可变和不可变的作用是单一的，只用来限定绑定关系是否可变。值本身的内容由值的类型
来决定，这么说有些抽象，还是拿 ~Greet~ 的栗子来说：

#+BEGIN_SRC swift
struct Greet {
    let age: Int32,
    var score: Int32,
}

func main() {
    let f1 = Greet(age: 10, score: 60)
    f1.score = 80 // Ok, 因为 score 是 var, 可变的.
    f1 = Greet(age: 20, score: 80) // Nope, 因为 f1 是 let, 不变的，不能改变绑定关系。

    var f2 = Greet(age: 10, score: 60)
    f2.age = 10 // Nope: 虽然 f2 是可变的，但是 age 在 struct 内部是不变的。
    f2 = Greet(age: 20, score: 80) // Ok, f2 可以重复绑定。
}
#+END_SRC

相对比来说， swift 的模型貌似更符合一个正常的心智模型，而 Rust 确是怪怪的，私自
以为 rust 对于 ~mut~ 的处理非常不合理，一个数据类型是否可变居然不取决于其自身的设计。
在设计之初，没有不可变的选择。:(, 相反在这一点上 ~swift~ 更加合理。

** 胡乱说的模型
如果 Rust 代码的语法是这样的，可能一致性更好一些：
#+BEGIN_SRC rust
fn main() {
    let x: mut Foobar = mut Foobar(0);
    let mut y: mut Foobar = mut Foobar(1);
    let mut z = mut Foobar(3);
    let o: Foobar = Foobar(4);
}
#+END_SRC
这样，第一个 ~mut~ 修饰绑定关系，第二个 ~mut~ 修饰内容就和 =借用/引用= 保持一致
了。：） 可惜现实不是这样的，我们姑且把 src_rust[:exports code]{let x: mut
Foobar = mut Foobar(0);} 这种看成是默认的语法糖吧。

* DONE 陪老 K 学 Rust (四)
:PROPERTIES:
:EXPORT_FILE_NAME: learn-rust-with-k-part4
:EXPORT_DATE: 2019-12-25
:END:

借用和引用
<!--more-->

** 词法空间
不久以前，Rust 的变量作用域是基于词法的，最近一年（可能）Rust 合并了 =非词法作用
域= 生命周期的特性 (NLL, No Lexical Liftime)，使得变量的生命周期不再严格遵循词法
域了，关于 NLL 的详细情况可以参考这篇文章：[[https://zhuanlan.zhihu.com/p/32884290]] .
下面的代码演示了基于词法域的变量生命周期：
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

Fn main() {
    println!("Before x");
    let _x = Foobar(1);
    println!("After x");
    {
        println!("Before y");
        let _y = Foobar(2);
        println!("After y");
    }
    println!("End of main");
}
#+END_SRC

#+BEGIN_QUOTE
在 ~x~ 和 ~y~ 变量之前加下划线是为了抑制 Rust 编译器的报错，对于不使用的变量，
Rust 会发出编译警告。
#+END_QUOTE

运行代码可以看出变量 ~_x~, ~_y~ 的生命周期是严格遵循作用域的。
#+BEGIN_EXAMPLE
Before x
After x
Before y
After y
Dropping a Foobar: Foobar(2)
End of main
Dropping a Foobar: Foobar(1)
#+END_EXAMPLE

如果去掉多余的 ~{}~, 猜测一下变量 ~_x~ 和 ~_y~ 的生命周期？它们会不是以创建的逆
序释放呢？验证一下：
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    println!("Before x");
    let _x = Foobar(1);
    println!("After x");
        println!("Before y");
        let _y = Foobar(2);
        println!("After y");
    println!("End of main");
}
#+END_SRC

#+BEGIN_EXAMPLE
Before x
After x
Before y
After y
End of main
Dropping a Foobar: Foobar(2)
Dropping a Foobar: Foobar(1)
#+END_EXAMPLE

可以看出，释放是按照创建的 *逆序* 进行的，值得信赖！

** 借用和引用
很多情况下，我们希望在不转移值的所有权(不改变变量的属主）的情况下使用变量。很简
单，Rust 提供了一种叫做 =引用= 的机制来满足我们的需求。 =借用= 和 =引用= 是一回
事，只是概念的侧重点不一致。 =借用= 是针对 =所有权机制= 而言的。 =引用= 是形式，
是针对变量使用的方式而言的。
#+BEGIN_QUOTE
通常变量变量的使用方式遵循两种形式： =值拷贝= 和 =引用=. =值拷贝= 是通过复制一个
新的值进行使用，在参数传递（通常的 =值传参=)，赋值等操作中使用. =引用= 是通过值复制值所
在的地址进行使用的，典型的应用就是在 =引用传参=, 值共享等场景。
#+END_QUOTE

编译下面的代码:
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn uses_foobar(foobar: Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x = Foobar(1);

    uses_foobar(x);
    uses_foobar(x);
}
#+END_SRC

编译器会输出如下的错误：

#+BEGIN_EXAMPLE
error[E0382]: use of moved value: `x`
  --> l15.rs:19:17
   |
16 |     let x = Foobar(1);
   |         - move occurs because `x` has type `Foobar`, which does not implement the `Copy` trait
17 |
18 |     uses_foobar(x);
   |                 - value moved here
19 |     uses_foobar(x);
   |                 ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
#+END_EXAMPLE

第二个src_rust[:exports code]{uses_foobar(x);} 使用了所有权已经转移的值。
根据编译器的建议，我们可以使用几种方法来修复：
1. 对于 ~Foobar~ 类型，我们实现 ~Copy~ trait.
2. 对于 ~uses_foobar~ 函数，我们使用 =引用传参= 的方式 =借用= ~Foobar(1)~ 的所有
   权，如同在 ~Drop~ trait 里面的 ~drop~ 函数的第一个参数 ~self~ 那样。

** 同时引用
不象所有权属主，一个值可以同时被多次以 =引用= 的方式使用。如下代码段:
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn uses_foobar(foobar: &Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x: Foobar = Foobar(1);
    let y: &Foobar = &x;
    println!("Before uses_foobar");
    uses_foobar(&x);
    uses_foobar(y);
    println!("After uses_foobar");
}
#+END_SRC
在这里， ~Foobar(1)~ 两次被以引用的方式使用，一次是作为 =引用参数= 直接传递给
~uses_foobar~, 另外一次是被变量 ~y~ 以应用的方式使用，并以参数的方式传递给
~uses_foobar~. 在这段代码中，局部变量 ~y~ 的类型是显示声明的，而不是使用的 =类型
= 推断的方式。代码输出如下：
#+BEGIN_EXAMPLE
Before uses_foobar
I consumed a Foobar: Foobar(1)
I consumed a Foobar: Foobar(1)
After uses_foobar
Dropping a Foobar: Foobar(1)
#+END_EXAMPLE

代码可以正常运行的原因在于。
1. 多次的 *只读* 引用不会引发数据竟态。
2. 值本身的生命周期要比引用的生命周期长，也就是说，变量 ~x~ 要比变量 ~y~ 的生命
   周期长。

src_rust[:exports code]{std::mem::drop} 函数可以主动触发值的失效操作。使用此函数
来结束变量 ~x~ 的值的生命周期。

#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn uses_foobar(foobar: &Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x: Foobar = Foobar(1);
    let y: &Foobar = &x;
    println!("Before uses_foobar");
    uses_foobar(&x);
    std::mem::drop(x);
    uses_foobar(y);
    println!("After uses_foobar");
}
#+END_SRC

编译器检查出借用的生命周期超出了其所有权属主的生命周期。
#+BEGIN_EXAMPLE
error[E0505]: cannot move out of `x` because it is borrowed
  --> l17.rs:19:20
   |
16 |     let y: &Foobar = &x;
   |                      -- borrow of `x` occurs here
...
19 |     std::mem::drop(x);
   |                    ^ move out of `x` occurs here
20 |     uses_foobar(y);
   |                 - borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0505`
#+END_EXAMPLE

** 可变引用
当然，我们也可以以 =可变引用= 的方式来使用某个值，为了避免数据出现竟态，Rust 不
允许同时出现多个 =可变引用= 或者在被可变引用的情况下以其他方式（包括 =只读引用=
）访问。
#+BEGIN_SRC rust
fn main() {
    let x: Foobar = Foobar(1);
    let y: &mut Foobar = &mut x;
    println!("Before uses_foobar");
    uses_foobar(&x); // 编译报错
    std::mem::drop(x);
    uses_foobar(y);
    println!("After uses_foobar");
}
#+END_SRC

#+BEGIN_EXAMPLE
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
  --> l17.rs:16:26
   |
15 |     let x: Foobar = Foobar(1);
   |         - help: consider changing this to be mutable: `mut x`
16 |     let y: &mut Foobar = &mut x;
   |                          ^^^^^^ cannot borrow as mutable

error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
  --> l17.rs:18:17
   |
16 |     let y: &mut Foobar = &mut x;
   |                          ------ mutable borrow occurs here
17 |     println!("Before uses_foobar");
18 |     uses_foobar(&x); // 编译报错
   |                 ^^ immutable borrow occurs here
19 |     std::mem::drop(x);
20 |     uses_foobar(y);
   |                 - mutable borrow later used here

error[E0505]: cannot move out of `x` because it is borrowed
  --> l17.rs:19:20
   |
16 |     let y: &mut Foobar = &mut x;
   |                          ------ borrow of `x` occurs here
...
19 |     std::mem::drop(x);
   |                    ^ move out of `x` occurs here
20 |     uses_foobar(y);
   |                 - borrow later used here

error: aborting due to 3 previous errors

Some errors have detailed explanations: E0502, E0505, E0596.
For more information about an error, try `rustc --explain E0502`
#+END_EXAMPLE

* DONE 陪老 K 学 Rust (三)
:PROPERTIES:
:EXPORT_FILE_NAME: learn-rust-with-k-part3
:EXPORT_DATE: 2019-12-24
:END:

从简单的栗子开始。

<!--more-->

** 从简单的栗子开始
#+BEGIN_SRC rust
#[derive(Debug)]
struct Foobar(i32);

fn uses_foobar(foobar: Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x = Foobar(1);
    uses_foobar(x);
}
#+END_SRC

src_rust[:exports code]{#[derive(Debug)]} 是一个编译器程序，这里让 ~Foobar~ 继承
~Debug~ trait, 以便于后面的 ~uses_foobar~ 函数中调用 ~println!~ 使用 ~{:?}~ 占位符进行插值打印。

src_rust[:exports code]{struct Foobar(i32);} 将一个 =元组= 封装成新的数据类型 =Foobar=.

运行程序可以看到打印输出。
#+BEGIN_EXAMPLE
I consumed a Foobar: Foobar(1)
#+END_EXAMPLE


现在修改一下 ~main~ 函数，我们仅仅是希望打印两次 ~x~ 的值，所以调用了两次
~uses_foobar~ 。
#+BEGIN_SRC rust
fn main() {
    let x = Foobar(1);

    uses_foobar(x);
    uses_foobar(x);
}
#+END_SRC

编译代码，可以看到编译器报错了：

#+BEGIN_EXAMPLE
error[E0382]: use of moved value: `x`
  --> l11.rs:11:16
   |
9  |     let x = Foobar(1);
   |         - move occurs because `x` has type `Foobar`, which does not implement the `Copy` trait
10 |     use_foobar(x);
   |                - value moved here
11 |     use_foobar(x);
   |                ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`
#+END_EXAMPLE

** ~Drop~ trait
Rust 的值在超出其作用域以后会被释放，内存也会被回收，这没什么槽点，因为在 C 语言
中，所有的栈上的 =局部变量= 也是这样的。 我们按照自己的思维定势来分析下发生了什
么。

#+BEGIN_SRC rust
fn main() {
    let x = Foobar(1); // 局部变量 x, 没问题。

    uses_foobar(x); // 传入 x 使用。
    uses_foobar(x); // 传入 x 使用。
}
// main 函数退出， x 被释放回收。
#+END_SRC

~Drop~ trait 是 Rust 中变量释放时运行的清理代码。其实现如下:
#+BEGIN_SRC rust
impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}
#+END_SRC

这里提前引入了 src_rust[:exports code]{&mut self} 这种参数传递方式，后面很快就解
释它。为了更清楚得分析，故意创造几个作用域并在关键点进行打印。
#+BEGIN_SRC rust
fn main() {
    println!("before enter scope");
    {
        println!("enter scope");
        let x = Foobar(1);
        println!("before uses_foobar");
        //uses_foobar(x);
        println!("after uses_foobar");
        println!("will leave scope");
    }
    println!("leave scope");
}
#+END_SRC

以上代码输出:
#+BEGIN_EXAMPLE
before enter scope
enter scope
before uses_foobar
after uses_foobar
will leave scope
Dropping a Foobar: Foobar(1)
leave scope
#+END_EXAMPLE

符合我们的预期，现在加入 ~uses_foobar~ 调用：
#+BEGIN_SRC rust
fn main() {
    println!("before enter scope");
    {
        println!("enter scope");
        let x = Foobar(1);
        println!("before uses_foobar");
        uses_foobar(x);
        println!("after uses_foobar");
        println!("will leave scope");
    }
    println!("leave scope");
}
#+END_SRC

输出：
#+BEGIN_EXAMPLE
before enter scope
enter scope
before uses_foobar
I consumed a Foobar: Foobar(1)
Dropping a Foobar: Foobar(1)
after uses_foobar
will leave scope
leave scop
#+END_EXAMPLE

看 =Dropping= 的时机，两个代码段明显不一样，而且第二个代码段的输出明显和我们预想的
不一样，发生了什么？

从感觉上来说，两段代码中 =x= 的释放时机应该没有区别. 但实际上，在第二段代码中，
x 在 ~uses_foobar(x);~ 之后就被释放了。这就是 Rust 所特有的所有权系统所起的作用。

众所周知，语言中的变量的生命周期都是基于词法域的。在 Rust 中，除了变量具有生命周
期， =值= 也有生命周期，每个 =值= 都 *有且只有* 一个其属主变量。 一旦 =值= 的属
主变量的生命周期结束，则值的生命周期也结束。当然，如果任何情况下， =值= 的生命周
期和 =变量= 的生命周期一致的话，所有权系统也就没有存在的必要了。既然其存在，就必
然有一些情况下， =值= 的生命周期和其属主变量的生命周期不一致。其中很常见的一种情
况就是：把 =值= 从其属主变量赋值给了另外一个变量，则新的变量就变成了 =值= 的属主
变量， =值= 的生命周期就保持和新的属主变量的生命周期保持一致。从这个角度来解释上
面的代码段二就是:

把 ~x~ 传递给 ~uses_foobar~ 函数时， ~Foobar(1)~ 的属主从变量 ~x~ 变成了函数
src_rust[:exports code]{fn uses_foobar(foobar: Foobar)} 的形参 ~foobar~,
在 ~uses_foobar~ 函数体结束后，形参 ~foobar~ 的生命结束， ~Foobar(1)~ 的生命周期
也随着 ~foobar~ 的生命周期结束而结束，故而调用了 ~Drop~ trait. 而代码一中，
~Foobar(1)~ 的属主变量从未改变过，一直是 ~x~, 所以在 x 退出其词法域而结束其生命
周期时， ~Foobar(1)~ 的生命周期才结束。

那搞得如此复杂的目的在于什么呢？或者说 Rust 搞这一套复杂的机制是为了解决什么问题
呢？主要为了两个目的：
1. 对于值，可以严格判定其生命周期，一旦其属主根据词法域结束生命周期后，就可以调
   用 ~drop~ 自动释放，从而做到了对于内存管理的 =零抽象=. 想想在 C/C++ 语言中的
   ~malloc~ 和 ~free~, 一方面，我们不得不时刻紧记要 ~free~ 内存，以避免内存泄漏。
   另一方面，我们还要时刻注意不要过度 ~free~, 从而造成野指针（好吧，其实现在 C++
   有智能指针了）。另外这种自动内存的管理不是通过 =引用计数= 或者 =GC= 来进行
   的，而是在编译期就可以确定的，避免使用一个保持 =引用计数= 或者 =GC= 能正常运
   行的运行时。
2. 对于多线程情况下，可以严格控制值的访问，避免出现多个线程代码同时访问同一个变
   量而引发的 BUG. 这种竟态往往是 BUG 出现的主要因素并且难以避免，难以复现，难以
   调试。往往我们需要借助静态代码分析工具来仔细分析，还不一定能够全部避免。按照这种所
   有权机制所提供的策略编写代码确可以 100% 避免这种情况，虽然这种策略看上去非常死
   板，不够灵活。但是作为一个码农来说，写正确的代码才是第一位的。当然不遵循这种
   策略可能也能写出安全的代码，但是遵循这种策略确一定能写出安全的代码，并且还自
   带静态分析工具，我们何乐而不为呢？

* DONE 陪老 K 学 Rust (二)
:PROPERTIES:
:EXPORT_FILE_NAME: learn-rust-with-k-part2
:EXPORT_DATE: 2019-12-20
:END:

万年的 ~Hello World!~.
<!--more-->

** 宏
#+BEGIN_SRC rust
fn main() {
    println!("Hello, world!");
}
#+END_SRC

很简单的 ~main~ 函数，跟 C 语言的 =hello world= 程序差不多。 =fn= 表示 ~main~ 是
一个函数，它没有参数，也没有返回值（严格来讲，其返回值是 ~()~ ）。 ~println!~ 看
上去是一个函数，实际上是一个宏，宏是一段运行在编译器上的代码。对，跟 C/C++ 的宏
类似，但是从功能上来说，Rust 的宏比 C/C++ 的宏更加强大。 宏和函数的区别可以通过
如下的例子来理解。

假如我们有一个 ~println~ 函数，它类似于 C 语言的 ~printf~ 函数，接受可以格式化的
字符串参数，可能会这样调用：
#+BEGIN_SRC rust
println("This is a string format print: name: {}, value: {}", name, value);
#+END_SRC
从编译器的角度来看， ~println~ 函数的第一个参数是一个字符串，其内部的插值占位符
~{}~, 编译器是无法理解的，这样的后果就是我们即使向 ~println~ 函数中传入 3 或者 4
个参数，编译器在编译阶段也不会报错。但是宏不一样，我们可以编写一段代码来操纵编译
器，使之能理解 ~println~ 函数的第一个字符串参数内部的占位符，从而对后面的参数个
数以及类型进行检查，一旦码农传入了非法的参数，在编译阶段就可以检查出错误来。那这
段代码就是 ~println!~ 宏，而且比 C 语言中的 ~printf~ 更强大，因为 ~printf~ 函数
是无法对参数进行合法性检查的。

#+BEGIN_QUOTE
思考：

是不是可以编写一个执行数据库检查的宏： src_rust[:exports code]{execute_sql!("select name, age from
user_table where age < {}", min_age);} 不仅能对格式化的参数合法性进行检查，甚至
能对其内部的 SQL 语句的合法性进行检查？
#+END_QUOTE

** =Trait= 和 =Display=

#+NAME: 程序一
#+BEGIN_SRC rust
struct Person {
    name: String,
    age: u32,
}

fn main() {
    let alice = Person {
        name: String::from("Alice"),
        age: 30,
    };
    println!("Person: {}", alice);
}
#+END_SRC

编译报错：

#+BEGIN_EXAMPLE
error[E0277]: `Person` doesn't implement `std::fmt::Display`
  --> t001.rs:11:28
   |
11 |     println!("Person: {}", alice);
   |                            ^^^^^ `Person` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Person`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
   = note: required by `std::fmt::Display::fmt`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`
#+END_EXAMPLE

错误的原因是 Person 没有实现 =std::fmt::Display= Trait. 实现这个 Trait 就能够修
复这个错误。

#+BEGIN_SRC rust
impl std::fmt::Display for Person {
    fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::result::Result<(), std::fmt::Error> {
        write!(fmt, "{} ({} yeas old)", self.name, self.age)
    }
}
#+END_SRC

结论：
1. Rust 中没有面向对象的概念， ~trait~ 也不是 ~class~, *没有继承*!
2. Rust 使用 ={}= 进行字符串插值时，被插值参数必须要实现 =std::fmt::Display= Trait.
3. =&self= 是 =self: &Self= 的语法糖。
4. =()= 类似 C 语言中的 =void=, 不同的是 =()= 既是类型，也是值。
5. 命名约定： 宏都以 =!= 结尾。
6. 与 C++ 不同，Rust 用 =::= 来表示域，C++ 用 ~:~ 。
7. ~&~ 表示使用 =引用= 的方式传参，这一点和 C++ 类似。

#+BEGIN_QUOTE
作为一个老鸟，肯定会思考：既然字符串插值的占位符是 ~{}~, 那如果要打印原始的 ~{}~ 该如何转义呢？

猜一下， 是 ~{{{}~ ? 不美观，而且看样占位符实际上是两个字符: ={= 和 =}=, 美观点
也应该是： ~{{}}~.

Right!
#+END_QUOTE

** 分号

#+BEGIN_SRC rust
impl std::fmt::Display for Person {
    fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::result::Result<(), std::fmt::Error> {
        write!(fmt, "{} ({} yeas old)", self.name, self.age)
    }
}
#+END_SRC

这段代码中的函数 ~fmt~ 函数体中只有一个语句： ~write!~, 而且这一个语句的后面 *没有*
分号！并且此函数明确标明了返回一个 ~Result~ 类型的值，但是函数体内部并没有
~return~. 这不是错误。Rust 是一门基于表达式的语言，也就是说，任何 Rust 语句都是一个表
达式，表达式的特点就是可以对其进行求值。语句分为两种：
1. 声明语句: 是一种特殊的表达式， ~let~, ~use~, ~crate~, ~fn~, ~struct~, ~trait~, ~impl~ 等等。这些使用其副作用的语句，其值为 ~()~.
2. 表达式语句: 由一个表达式和分号共同组成的语句。在一个表达式后面添加 ~;~ 就构成了表
   达式语句。当使用 ~;~ 把表达式强制变成语句之后，则此表达式语句的值被抑制，强制变为 ~()~.
  
#+BEGIN_QUOTE
思考

既然 Rust 中一切都是表达式，为什么还要在表达式的后面添加一个 ~;~ 使之变成表达式
语句？
#+END_QUOTE

既然在 Rust 中一切皆表达式，则 ~{}~ 组成的代码块也是表达式。由 ~{}~ 组成的代码块
的表达式的值就是 ~{}~ 最后一个表达式的值。
#+BEGIN_SRC rust
let a = {
    let inner = 2;
    inner * inner
}
#+END_SRC

上面代码中 ~a~ 的值是 4. 但是如果 src_rust[:exports code]{ inner * inner } 用
~;~ 强制转换成语句后， ~a~ 的值和类型都变成了 ~()~.

函数的返回值也一样，在 Rust 的函数体中，最后一个表达式的值作为函数的返回
值。 ~return~ 语句通常用在提前返回的情况下。

** 数字类型

Rust 中的数字类型都是明确的，并且类型之间只能使用 ~as~ 进行显示转换，不允许类似
C 语言那样的隐式转换。Rust 的类型名称也比较有规律：

#+ATTR_HTML: :border 2 :rules all :frame border :class striped table-striped noboldheader
|--------+--------+--------+--------+----------+-----------|
| 单字节 | 双字节 | 四字节 | 八字节 | 十六字节 | 四/八字节 |
|--------+--------+--------+--------+----------+-----------|
| i8     | i16    | i32    | i64    | i128     | isize     |
| u8     | u16    | u32    | u64    | u128     | usize     |
|--------+--------+--------+--------+----------+-----------|

再也不用费劲记忆 ~short~, ~int~, ~long~, ~longlong~ 是多少字节了。:)
~iszie~ 和 ~usize~ 比较特殊一点，想来是为了方便和 C 进行混合编程。

** 循环打印数字
#+BEGIN_SRC rust
fn main() {
    let i = 1;

    loop {
        println!("i == {}", i);
        if i >= 10 {
            break;
        } else {
            i += 1;
        }
    }
}
#+END_SRC

#+BEGIN_SRC rust
fn main() {
    let i = 1;

    while i <= 10 {
        println!("i == {}", i);
        i += 1;
    }
}
#+END_SRC

以上代码都有编译错误，主要就是需要注意可变变量和不变变量。 比较奇怪的一点是既然
有 ~while~ 了，为什么还增加一个 ~loop~? 一种说法是对于循环来说， ~loop~ 更方便编
译器检查错误，因为只要其中不包含 ~break~ 语句，就会被编译器检查出来，但是 ~while~ 语
句的条件检查只有在运行期才能知道，编译期是无法知道的，也就无法在编译期进行检查。

#+BEGIN_SRC rust
fn main() {
    for i in 1..11 {
        println!("i == {}", i);
    }
}
#+END_SRC

~for~ 语句和 C 长得不一样了， Rust 的 ~for~ 变成了 =迭代= 的形式。

